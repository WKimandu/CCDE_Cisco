start	end	text
0.0	15.6	 Okay, I will go ahead and get started. Appreciate you all for showing up. I know that this is
15.6	19.56	 probably the last session separating you and something down at the General Assembly, so
19.56	25.76	 I appreciate the audience. A couple of housekeeping items. The headphones are there to hear if
25.76	29.12	 you haven't been here before. There is a volume control on one side. It depends on which side
29.12	32.64	 it is so you can raise or lower my voice. I don't know if they are sound canceling,
32.64	35.72	 but you can turn all the way down and get a great nap if you are interested. The other
35.72	39.160000000000004	 thing is that when you touch them, there is also a side that changes the color of the
39.160000000000004	44.24	 outside band of the headphone. Make sure they are on that white looking bluey color. If
44.24	47.400000000000006	 they are different colors, you will pick up different channels and it may be a better
47.400000000000006	52.36	 presentation but you won't hear me. So with that, we will go ahead and get started. My
52.36	56.480000000000004	 name is Quinn Snyder. I am a technical advocate with Cisco Learning Certifications. But prior
56.879999999999995	61.04	 to moving over to Cisco L&C, if you can't tell by the back of my laptop, I was a developer
61.04	68.03999999999999	 in DevNet for three years and I really have a fascination and love for all things infrastructure
69.96	74.8	 as code, including Terraform. So I have done some introductory discussions around Terraform,
74.8	78.17999999999999	 really how to use it and how to get started, but I wanted to take that up to the next level
78.17999999999999	83.47999999999999	 and cover some more advanced or esoteric things within Terraform. So I have got to put this
83.48	87.12	 presentation together. It is my first run of it, so hopefully it hits the complexity
87.12	94.12	 level. But if not, I appreciate you attending anyway. So we will have, there is a DevNet,
95.60000000000001	102.52000000000001	 there is a WebEx room that is available for this session. My slides aren't super dense,
102.52000000000001	107.54	 but I will post a PDF in there as well as on the GitHub repository because most of this
107.54	112.08000000000001	 I hope to be a hands-on demo and show you some of the things around Terraform and how
112.08	115.52	 we can improve the experience as well as how we create things like modules, et cetera.
115.52	120.8	 So I will have a QR code with my GitHub repository and I will drop that link as well in the WebEx
120.8	126.64	 room probably later tonight after I have had a chance to get some more coffee. So on the
126.64	131.84	 agenda today, it is going to be a lot of Terraform commands. So I want to talk, the first three
131.84	136.07999999999998	 things on that list are really creature comforts and items around how do we make Terraform
136.07999999999998	140.84	 a little bit easier to consume. So I will talk a little bit about TFN, which are those
140.84	147.56	 who have used Python and PyN or something like ASDF or MyZonGuard. It kind of provides
147.56	152.04	 the same feature functionality there. I will talk about Terraform format or FMT, how we
152.04	156.2	 make our HCL a little bit more readable if we don't worry about that at the front end.
156.2	159.68	 I will talk about Terraform graph and how we can use that to get some output from our
159.68	164.92000000000002	 Terraform plans to show what is going to happen under the covers when we run a Terraform apply.
164.92000000000002	169.04	 And then the next two things are really focused on the usage of Terraform itself. The Terraform
169.04	173.14	 console. And my focus of that is really on how we get variable manipulation to occur
173.14	178.07999999999998	 properly inside of Terraform. I know there is a lot of struggle with we have these data
178.07999999999998	182.28	 structures where they are written in YAML or JSON or others. That we have this structure
182.28	185.88	 that has been predefined. Maybe we are using something like Netbox as a source of truth.
185.88	189.95999999999998	 We need to export those things and manipulate them to get the right output format for our
189.95999999999998	195.2	 variables before we put that into Terraform. We can use Terraform console to manipulate
195.2	198.07999999999998	 those things. I want to show you some of the tricks and tips and some of the things that
198.12	201.88000000000002	 I do with Terraform console before I build my plans to make sure I am doing things the
201.88000000000002	205.48000000000002	 right way. And then finally I will wrap it up with Terraform modules. So how we create
205.48000000000002	210.48000000000002	 a higher level automation or abstraction I should say across Terraform so we are not
210.48000000000002	215.48000000000002	 entering the same variables over and over again for the same repetitive work. So we
215.48000000000002	222.16000000000003	 will go ahead and get started. So first of all, before I get started, how many folks
222.16000000000003	227.96	 have used Terraform at all? How many feel that you are fairly proficient with Terraform
228.04000000000002	232.4	 at least building the HCL, being able to read the documentation, someone asks you to build
232.4	235.0	 something new in the cloud and you are like okay let me look at the docs and build the
235.0	241.24	 HCL. Yeah, okay, perfect. So we are level set about the right audience here. So one of the
241.24	245.44	 things that I do when I build, when I have worked with any infrastructure's code, I know
245.44	252.44	 Ansible has its own baggage. So I have used PyEN for a lot of my work. Terraform has made
253.44	258.96	 that much easier because I have said before it is a precompiled go binary. So we just
258.96	263.96	 download that binary and install it to path and we are off the races. The problem is that
263.96	267.56	 if we want to run different versions of Terraform or use different versions of Terraform, say
267.56	271.44	 we are looking at our dev test environment where we are going to use the new version
271.44	276.52	 in this case it is 196 is the latest release but maybe we are stuck on 17. Do we have compatibility
276.52	280.24	 with our HCL and how do we test and verify that? You are kind of left up to your own
280.24	284.86	 for semantic versioning because every binary is named Terraform so it is incumbent upon
284.86	290.40000000000003	 you to say this is Terraform 176 or whatever or however you are going to notify that. So
290.40000000000003	296.72	 there needs to be, it is not a need, it is a nice to have but I like to do it. There
296.72	301.52	 is no really good way to manage Terraform versions on your own. And so that is where
301.52	308.36	 Terraform TFN comes in handy. So this is a CLI tool that you can install under your work
308.36	313.92	 station, Mac, Linux, it doesn't natively support Windows I don't think but it does
313.92	318.8	 support WSL and it is a CLI tool that manages the installed version of Terraform into your
318.8	324.8	 path. So how many of you have used pie ENV before? Okay, same kind of principle. I do
324.8	331.44	 TFN if I can list remote or list it local install and I can switch those versions in
331.44	338.28000000000003	 between either manually by using a TFN views or if I have a .terraform version file installed
338.28	342.15999999999997	 inside of my local directory it will automatically switch the versioning based on what I have
342.15999999999997	348.2	 there. So very easy to install and it supports all versions of Terraform so not just the
348.2	353.64	 major versions that are in this slide here so if we go to terraform.io these are the
353.64	361.64	 ones that we can download and install directly from terraform.io. This will, excuse me, TFN
361.8	369.59999999999997	 will allow you to install all of those so let me just show you that real quick. So right
369.59999999999997	381.59999999999997	 now I have 198, 185, 175 and 145 installed on my system. However, we can do a TFN list
381.59999999999997	388.03999999999996	 remote and we can see that there's a, we can install whatever version of Terraform that
388.04	393.96000000000004	 we want there so we can do all kinds of crazy regression testing using TFN and this includes
393.96000000000004	398.56	 alpha versions, beta versions. They do a really good job of making sure that it's accessible
398.56	404.56	 for everything. However, if we want to go and what I'll do here, so if I do terraform
404.56	414.0	 version, like I said we're using 198 locally in this main DevNet 2565 folder. I'm going
414.0	420.32	 to move into this 02 graph folder and because we have this terraform version which is simply
420.32	424.88	 just the version number, 185, we can see that before I had that installed on my system,
424.88	435.56	 it's actually easier if I just do it here. We can see now but if I do TFN list we can
435.56	440.0	 see that because I have that terraform version file it's automatically set by that terraform
440.0	445.12	 version. So now I have a way that I can very easily manage semantic versioning of terraform
445.12	451.68	 on my system in a per directory or per project level. So again, kind of a creature comfort,
451.68	456.52	 it's not a necessity but as we start going especially with the rapid change within the
456.52	461.8	 providers themselves, things like AWS and the GCP providers, sometimes there's a linkage of the
461.8	465.84	 newer features being supported because of the way that the graphs are changing under the hood of
465.84	477.35999999999996	 terraform itself. Okay, making your terraform files readable. So one of the things that I've
477.35999999999996	482.88	 talked about kind of ad nauseam with terraform, especially when people ask me is it terraform
482.88	487.79999999999995	 or ansible which do you prefer, I say that there's both but they have their pros and cons. I always
487.79999999999995	492.47999999999996	 say that terraform is that end state declarative nature, right? We build the entire set of
492.48	498.8	 instructions of what we want that end state to look like and because we're using the native go,
498.8	504.88	 I mean HCL is not go but it has looks and feels like go, there's a very strong and well-typed
504.88	511.84000000000003	 syntax and structure. So we use those curly braces to denote ends of our arguments and blocks and we
511.84000000000003	519.24	 don't need to worry about all that weird white spacey type stuff. However, there is a way that
519.24	525.72	 terraform can be very prescriptive in how you format or make these things readable so you're
525.72	530.48	 not worried about matching up these curly brackets. It'll structure it out for you in a way kind of
530.48	534.02	 similar to like what Python Black will do if you run that inside of your code. It does all that
534.02	538.64	 linting and formatting for you. Well terraform took that and built it in automatically so you can use
538.64	543.5600000000001	 terraform format to do all that heavy lifting. So all that formatting that you would normally do or
543.5600000000001	547.46	 try to do all that white space, you can just throw it to terraform format, doesn't matter how it's
547.46	551.7	 written, it will structure it in the way that makes it easier to read. And on the plus side,
551.7	557.98	 just like everything else terraform, it only impacts .tf files. So if you have other text files or
557.98	562.86	 other back files or whatever, it's only going to change the format of those even to the point where
562.86	569.7	 in my demo I have this terraform format .backup or main.tf.back or something like that and it's
569.7	573.7800000000001	 formatted and it is HCL but because it doesn't have the right extension it will not be impacted.
573.78	580.86	 And so this is kind of a similar way of what happens kind of from my demo and I'll show that
580.86	585.38	 actually in real time as well. I just have a simple fabric inventory from something from NDFC,
585.38	595.06	 so I'm building a list, sorry a map of maps basically for devices that would be in a VXLan
595.06	599.86	 fabric. So I have my spines, I have my leafs, I define IP addresses, I define roles, but I've
599.86	607.7	 left them all left justified and I've just said I want to get what I want my inventory to look
607.7	615.0600000000001	 like. Yes you can read it and syntax highlighting is great as based on carbon.now.sh but there's
615.0600000000001	618.26	 ways that we can make it a little bit easier and in fact if we notice it's a subtle difference,
618.26	623.26	 but in terraform when we define maps we can say maps of a certain type. We can do map,
623.26	629.58	 we can do map string, we can do map all that provides an input validation for what goes
629.62	634.74	 into our map. In this case it actually took my map and said I don't know even though these are
634.74	639.22	 all strings I can't discern that they're all going to be strings in perpetuity, so let's have a map
639.22	645.5400000000001	 any. So any type of input that I put in there whether it's a boolean, whether it's a number,
645.5400000000001	650.98	 or a string will be supported properly inside of that map argument. And that's just by running
650.98	659.4200000000001	 terraform FMT. So what I will do here just to prove here's something similar that I had
659.42	665.54	 before. I have variables, users, and I have that same kind of map for fabric inventory,
665.54	672.42	 but you can see it's all just left justified and completely strung out. And I have this main.tf.source
672.42	689.18	 and I'm going to copy this and paste and rename to just main.tf and move into, you can see that's
689.18	703.5	 there. And if I just run a terraform FMT, happens instantly you can see that it has formatted all
703.5	708.9	 those things to make them a little bit readable. Now more to the point, because terraform is not
708.9	715.6999999999999	 whitespace dependent like YAML, it may do things like this. So whereas before in the source all of
715.7	720.38	 these were single space separated between the equal signs there, in this case it will give me an
720.38	725.82	 equal number of spaces to ensure that my arguments are aligned. So it makes it very easy to say here's
725.82	731.86	 my values and my arguments inside of a map or inside of a single assignment and correlate them
731.86	736.58	 appropriately. So everything's nested in a very nice and convenient way. Again, not a necessity,
736.58	739.86	 but these things are kind of creature comforts as we start sharing code to ensure that we're all on
739.86	751.38	 the same page. All right. Visualizing object relationships. So when we're working with terraform,
751.38	756.54	 we all know, and like I said before, that it's end state declarative. I write what I want to build
756.54	764.1800000000001	 and I build that. And if you really want to know how terraform does that, you can, when I pass the
764.1800000000001	769.1800000000001	 slides or hand the slides off into the WebEx room, you can click on that link and there is a
769.3	775.06	 compendium. I mean it is pages and pages of how terraform goes about building its individual
775.06	779.9	 resource graphs. Long story short, when you build a provider, there's lots of dependencies that go
779.9	786.2199999999999	 into that based on how that's structured. And when you do that, sorry, when the provider is built like
786.2199999999999	793.18	 that, that's how we can guarantee that when I say in the case of ACI, we have a tenant and a VRF and
793.18	796.78	 a bridge domain and a subnet and contracts and filters and all the things that go behind that,
796.78	802.66	 we can ensure that the order that they will be applied will not cause anything to break. Unlike
802.66	807.8199999999999	 Ansible, where I have to make sure that order A, B, C, and D is there, I do not have to do that with
807.8199999999999	812.98	 terraform. That's why we use it, especially for cloud. However, when it comes to the visualization
812.98	818.74	 of how these things flow, you can actually use terraform to build a graph of what that will look
818.74	825.62	 like and all those dependencies. And not only does it build based on the individual provider itself,
825.94	831.62	 but if you've ever used the depends on argument inside of terraform, where we say maybe in Azure,
831.62	838.62	 we're building like a VPN, or we have a network that's set up that we're going to have a VPN tied
838.62	842.3	 to, we need to make sure we have those subnets applied to that network prior to building that
842.3	847.3	 VPN because there's a dependency there. We do depends on, it will add those as elements into
847.3	855.22	 that graph. Now by default, it visualizes it in dot format, and I'll show what that looks like,
855.22	859.94	 but that's something built by graph viz. But using the dot command and graph is built in,
859.94	865.6600000000001	 if you have it installed, whether it's your Mac or your Linux PC, you can convert that to a PNG.
865.6600000000001	872.14	 Now what's important about this is when we run that terraform graph command, it uses all files
872.14	876.34	 in the project folder. So just like the normal terraform routine, we have to do the init,
876.34	880.4200000000001	 and then we would do a plan normally. You still have to make sure that the init is there because
880.42	884.5799999999999	 if you're using a third party provider, it has to be there to build that resource graph,
884.5799999999999	889.42	 and then more appropriately, if you're doing something remote, it may need to be able to
889.42	893.4599999999999	 communicate if you have a tf.state file in there as well because it's got to read that current
893.4599999999999	898.4599999999999	 state of information before it can say here's how that resource graph looks. In my case,
898.4599999999999	902.74	 I have a clean folder so you can do it, but if you have an existing terraform state,
902.74	906.14	 you will need to make sure that you have some kind of connect to that existing resource because
906.14	909.54	 it's going to read in that state as well for any changes because it's reading the current
909.54	919.0999999999999	 state of that terraform plan. Makes sense? So a .file kind of looks like this, and you can see
919.0999999999999	922.2199999999999	 where it makes sense. We've got some labels of things. We've got different shapes that are
922.2199999999999	926.74	 defined there, and you can kind of discern what this looks like. This is no different. I know
926.74	932.4599999999999	 that in the olden days, there was a cumulus Linux platform that would do something similar for the
932.4599999999999	937.14	 white box stuff, but anyway, you can see where this all comes out, and you can see, okay, I can
937.26	946.5	 shape that together. However, if we go here to our graph, and I will show that here real quick.
946.5	958.46	 So in this case, this is something that I've demonstrated, probably ad nauseum for ACI
958.46	965.46	 demonstrations. So I'm just using the ACI provider. I have some variables here, username, password,
965.46	971.5400000000001	 URL to access the ACI fabric. I've built some bridge domains, some subnets, a VRF, a tenant.
971.5400000000001	976.94	 Now, if you look at this and you're familiar with ACI, you say that's out of order. We have this
976.94	983.1	 bridge domain defined before we have our tenant, before our VRF, and those kinds of things, but
983.1	988.4200000000001	 because of that resource graph, Terraform will handle that natively and say, I'm going to construct
988.4200000000001	992.82	 it in the way that makes sense, and you can prove that out by using the terraform graph command.
992.82	1004.4200000000001	 So what I'm going to do here rather than me typing this, so we can do terraform graph. In this case,
1004.4200000000001	1007.74	 I'm going to look at a plan. So what's going to happen when we go through the plan, you can do a
1007.74	1014.3000000000001	 type action. So there may be a difference between a plan and an action, I'm sorry, apply based on
1014.3000000000001	1020.1	 the terraform state, and I also include the dash draw cycles. Now, if anyone has run some very
1020.1	1024.66	 complex terraform plans, have you ever noticed where sometimes it has to go through twice or
1024.66	1028.54	 three times before it will complete everything because of the order in which it has to wait and
1028.54	1032.58	 build? So you build some stuff and then it has to rest, or maybe you've done some parallelism,
1032.58	1036.78	 then it has to go back and complete the second cycle. If we include the draw cycles, it doesn't
1036.78	1040.7	 do anything for this one because it's simple. If you include draw cycles, it would include the
1040.7	1047.14	 recursion that has to happen through that terraform plan. So just the draw cycles, oops, and you can
1047.14	1052.66	 see it depends on having the terraform initialized. So let's do the terraform init, bad on me.
1052.66	1065.66	 Come on, internet. Perfect. Okay, so the terraform graph, and you can see that's just that same
1065.66	1073.3400000000001	 output that I had before, nothing fancy, but it is building based on that main.tf and the variables.tf,
1073.34	1078.4199999999998	 so it's reading all those files in to build what it will look like. And then if we go one step
1078.4199999999998	1087.06	 further by doing this, where we pipe it to dot and then do the output as being a PNG and then
1087.06	1099.86	 redirect that to tfcycle.png, we should have a new image right here. And that's what it looks like.
1099.86	1105.58	 So you can see the hierarchical order that would be normally expected to build these things inside
1105.58	1111.54	 of ACI. We now have the provider which ties the tenant, the VRF, the bridge domain, the subnet,
1111.54	1115.58	 that hierarchy is built, and on top of that you can see where each one of those variables is
1115.58	1119.58	 referenced. So we have a nice handy visualization that you can hand off to someone to say, here's
1119.58	1124.9399999999998	 my terraform file, but here's the output of what that will build with the included names,
1125.38	1130.8600000000001	 because you can see it still includes that dotted tuple, so the ACI bridge domain dot terraform BD,
1130.8600000000001	1135.9	 that aligns the names that I put inside of my terraform plan, so you can correlate, here's the
1135.9	1141.66	 order, here's the variable names, here's the resource names, and align that all together. So
1141.66	1145.78	 it's handy to be able to document that, if nothing else, as part of your documentation to say,
1145.78	1153.3400000000001	 here's what the automation did for me. Okay, now probably more why you're all here, because you
1153.34	1157.78	 want to know more than just the creature comforts. So I want to talk about interactive-ish terraform.
1157.78	1166.34	 So generally, when we work with terraform, this is the cycle that we follow, and we write our
1166.34	1170.86	 HCL, we do a terraform plan, because we want to know what we're doing before we do it, we do a
1170.86	1175.98	 terraform apply, invariably if I'm writing a terraform plan, something's gonna break in there.
1175.98	1180.3	 Maybe I don't have my variables associated the right way, maybe something doesn't apply the right
1180.3	1185.58	 way, maybe I've got some dependencies, so something's broken, and I'm going to rewrite my HCL to figure
1185.58	1189.6599999999999	 that out. And that can be time-consuming, because it's like there's got to be a way where we can
1189.6599999999999	1195.26	 interrogate the variables of the data structures that we're building ahead of time, so we know our
1195.26	1202.4199999999998	 HCL is gonna work the first time every time. But typically, this is my cycle, and it works fine for
1202.4199999999998	1207.3799999999999	 simple HCL, since most of your errors are probably like syntactical, or if you're like me, you can't
1207.38	1211.5800000000002	 type half the time, especially when people are watching. More often than not, we'll do a very
1211.5800000000002	1217.9	 simple variable, so we have simple assignments or simple maps, so that makes it easy to troubleshoot.
1217.9	1223.5800000000002	 But we want to be able to interact with terraform in a way, especially at a variable level, to say
1223.5800000000002	1228.42	 how can I ensure if I have a data structure, whether that's defined based on some organizational
1228.42	1233.42	 standard, whether that's output from Netbox, or some other single source of truth, or maybe we have
1233.42	1239.46	 some output data from a CSV file, how do I know that that output is going to be manipulated in such
1239.46	1244.74	 a way for a structure that I can automate against? I mean, really, that's the hard part. Everything
1244.74	1248.78	 else is just writing HCL, but we need to make sure we have the right data coming in to apply it
1248.78	1257.42	 correctly going out. So terraform has a console. Anybody know that before? Anybody use terraform
1257.42	1264.66	 console? So terraform console allows for interactive interrogation of terraform. So we can look at
1264.66	1269.98	 things like variables, we can look at configuration, we can look at the state file if it's already been
1269.98	1274.78	 applied, so we can gather that data out of terraform. And what I use it for more often than not is
1274.78	1280.42	 variable and data interpolations based on built-in functions within terraform. So there's things like
1280.42	1284.1000000000001	 flattened, there's things like squash, there's things that we can manipulate, and I'll show what
1284.1	1289.1399999999999	 those structures look like to be able to say we have this map, do some queries on that map, spit out
1289.1399999999999	1294.98	 this condition if switches a spine, and what does that look like? So I use that to manipulate my
1294.98	1299.9399999999998	 variables before I write my HCL to know here's the data structure and here's how I need to build my
1299.9399999999998	1307.62	 terraform plan. However, and I will demonstrate this as well, the terraform console is not a
1307.62	1313.58	 REPL. So with Python, we have the interactive Python where we can say, you know, assign variables
1313.58	1318.58	 and we can build our entire function inside of that REPL and validate it that it works beforehand.
1318.58	1327.26	 We cannot do the full set of REPL operations in terraform console. So it's mostly like a static
1327.26	1332.4199999999998	 piece. There are some, it will build your files, it will look at your files, it will gather them
1332.4199999999998	1339.3799999999999	 all together, but it's not an interactive REPL type console. So what I want to do here is demo a lot
1339.38	1353.2600000000002	 of this. So let's go simple interrogation. So under this 03, let me close these up, I have this main.tf.
1353.2600000000002	1358.7	 Now, I just have a single file here and I've thrown all of my variables inside of what's called
1358.7	1364.66	 locals. Locals in your normal terraform plan is just a way you can store local variables or data
1364.66	1371.94	 structures that you would like to work on. It can ingest full blown terraform plan. So if I was to go back
1371.94	1377.18	 to that graph example, I could also do terraform console there. However, rather than dealing with
1377.18	1381.02	 all the idiosyncrasies, I've just tossed a bunch of things here in locals so I can do some very,
1381.02	1388.5800000000002	 some simple variable manipulation here. So I have a blank variable called leafs. I have a simple assignment
1388.5800000000002	1393.8200000000002	 called session ID and I have this thing called user, this map called user, I have username, password,
1393.82	1399.98	 URL, and I have this thing called fabric and some leaf for stuff. So to access the terraform console,
1399.98	1407.82	 I'll just do terraform console. And you can see here that I have this terraform.tfstate backup or
1407.82	1414.54	 lock info and terraform.tfstate. Just like with terraform graph, if I have something that depends
1414.54	1418.54	 on a provider, I need to do a terraform init first because it needs to know how to interact with it.
1418.54	1423.5	 However, because I've tossed everything in locals, it just builds a temporary terraform.tfstate as
1423.66	1428.38	 well as a lock to say no one else can modify this before you're out of the console because
1428.38	1436.06	 you're directly interacting with that HCL. So in the repository that I have linked at the very end
1436.06	1441.74	 of this presentation, I have this command.text file. So you can reference this again. This is so I don't
1442.78	1448.86	 fat finger anything when I copy paste. So we can do simple variable lookup. So we can do like local,
1448.9399999999998	1456.9399999999998	 oops, do something called local.session ID. And we can spit back a value so we can see that that is
1456.9399999999998	1465.26	 ingested in the sign. We can go a little bit deeper. We can go local.user.username. So we can
1465.26	1471.26	 pick back individual pieces of our map. So just like you would reference as a var.user.username,
1471.26	1478.4599999999998	 same thing you can do within the console. We can do some simple, let's see here if I have that there.
1479.82	1485.02	 Yeah, so we can do some simple stuff. I think we have this leaf4. Yeah, so we have this leaf4.
1485.02	1491.26	 We could actually split these things up. So in this case, I have the split function. So split just
1491.26	1499.1799999999998	 says kind of just as you would in Python, we have split the variable local.leaf4.ip based on the
1499.1799999999998	1505.1	 dot inside of the octet. So in this case, I can run something like that. And it splits it out to a
1505.1	1510.86	 list. So now I have a list object there where it has 10, 10, 20, and 176. So it's divided each of
1510.86	1518.2199999999998	 those octets into a list. And then on top of that, because it's a list item, I can then
1522.4599999999998	1528.2199999999998	 query an individual item within that list. So I can do the same types of functions that I would
1528.2199999999998	1533.98	 normally inside of any other programming language. So I can take that and split that out. Again,
1533.98	1537.9	 this is just an esoteric example. But if I need to do something a little bit deeper to dive in,
1537.9	1541.58	 maybe I've got a list I need to extract something out, I can reference those items
1541.58	1547.58	 based on the list value and number. The other way that I use
1551.26	1554.54	 this is we'll go a little bit deeper here.
1555.26	1564.1399999999999	 And we have this again, something simple. It's just a list of maps. I have a map called, sorry,
1564.1399999999999	1571.8999999999999	 the first item in that list is called item one with values A and B. The second map in that list
1571.8999999999999	1582.54	 is item two with values B and C. So what I want to do here is test the list. So I'm going to
1583.5	1588.94	 is test. Maybe you have some kind of data structure where you need to ensure that I have
1588.94	1595.1	 item one tied to value A and B and item two tied to value B and C. So in that case,
1597.26	1603.8999999999999	 I have this sample variable file or sorry, sample manipulation called squashed. And in this case,
1603.8999999999999	1609.18	 I'm going to flatten that set of lists. So it's all flattened out. And then I'm going to do some
1609.18	1613.18	 simple, well, not so simple because it's a little bit confusing my variable names here, but I'm going
1613.18	1620.6200000000001	 to do some iterations over that flattened set of lists. So for entry in the list of maps,
1620.6200000000001	1627.74	 for the thing in the values of entry, create a map denoted by the brackets here. And this is
1627.74	1632.46	 the one thing that is very important with Terraform console. You can see where I have the curly braces
1632.46	1637.74	 there. Everything instead of a curly brace denotes a map. If I was to move that to square brackets,
1637.74	1641.42	 I would have a value error because I'm not creating a list. I'm creating a map,
1641.42	1645.66	 which is like a Python dictionary of key value pairs. So you need to make sure that you're
1646.6200000000001	1652.78	 through all of this, you need to make sure that you have your, I don't know, delimiters correct.
1652.78	1659.34	 So in this case, my list is the square brackets, a map is those curly braces. So if I run this,
1659.34	1668.6999999999998	 hopefully something's not broken. All right, let's try it anyway. So because it's in locals,
1668.6999999999998	1674.3799999999999	 and because Terraform automatically initializes all of these different items, it says I'm going
1674.3799999999999	1680.78	 to compute everything before I fire up the console. So I should be able to do local.squashed,
1680.78	1690.86	 and you can see that it has taken A in item one, B in item one, B in item two, and C in item two.
1690.86	1696.22	 So I've created a set of pairs instead of having those reference lists. What this is illustrating
1696.22	1701.5	 is that when I run Terraform console, it's actually initializing every piece of resource
1701.5	1706.86	 and data source and everything else inside of that code prior to running the console. So you can use
1706.86	1712.6999999999998	 this as a validation point prior to doing a Terraform plan, prior to doing a Terraform apply,
1712.6999999999998	1717.26	 to make sure do things look right based on my outputs. And I can view outputs through here,
1717.26	1726.4599999999998	 I can view variables, I can view locals, etc. Exit out of here, and we'll do some final examples
1729.02	1730.86	 with some more complex manipulation
1730.86	1740.78	 in this main.tf. So in this case, I have kind of similar to what I had before. I had these
1740.78	1746.06	 leafs equals this, sessions IDs, and I have this fabric inventory based on spines and leafs and
1746.06	1752.86	 things like that. Then I have this demo VRFs, VRF A and B. So first of all, just to illustrate this,
1752.9399999999998	1755.9799999999998	 I can iterate through, let's see here, Terraform console.
1757.9799999999998	1765.1799999999998	 For the object in the local fabric inventory, so remember that's that set of the list of maps here,
1767.8999999999999	1774.1399999999999	 print the name of each of those, or print the value of the name variable. So in this case,
1774.1399999999999	1780.9399999999998	 it's going to be leaf1, leaf2, spine1, spine2. You can see here, it's going to enter the value of
1781.9	1785.5	 the map. You can see here, it's going to iterate through those things. So we can capture out just
1785.5	1790.14	 as we did before, where we captured the individual values out of those maps. We can do that across
1790.14	1795.9	 the list. But as an example here, like I've said before, it's important to make sure that we have
1795.9	1800.06	 the right structure that we're building with the right delimiter. Because this is the same thing,
1800.06	1805.5	 but I've used curly brackets instead of squares. And you can see it's failing. Key expression is
1805.5	1809.42	 required when building an object. So it will tell you where you have those syntactical errors with
1809.42	1817.9	 inside of your Terraform structures ahead of time. Another nice thing is what Terraform calls
1817.9	1823.02	 the splat. So instead of having that loop list where I said for all in local fabric,
1823.02	1829.42	 I can just do local fabric inventory splat and gather that same bit of information using that.
1829.42	1836.22	 So I can iterate over a list without having to build a loop for it. I can build maps. So we can
1836.22	1844.22	 see here four key value in the inventory. So whenever I build a complex expression inside
1844.22	1849.74	 of Terraform, I have my loop defined there. And if I want to do one line, I will do a colon to
1849.74	1856.78	 separate that. And then to build a key value pair like I would in Go, it's key arrow value.
1858.6200000000001	1864.22	 So this should build a set of maps based on number there. So I've given it a name
1865.18	1870.3	 based on the number there. So I basically just constricted. I've created a map of maps
1870.3	1879.5	 instead of the list of maps. And that also works across the splat character here.
1882.06	1890.06	 And I get the same item there. We can build lists again because we have the square brackets.
1890.06	1893.4199999999998	 I just want to gather all the rolls out of that local fabric inventory.
1894.3	1898.62	 And I would do that here. Gather those things out. And then finally, I'll do some complex
1898.62	1908.22	 manipulations here just to save some time. Sounds like they're having fun. In this case,
1908.22	1912.7	 I'm doing a little bit more of a manipulation. Same thing as I did before. Build a map,
1912.7	1919.82	 but only if the value of the roll field is set to spine. So I can do some parsing of the local
1919.82	1923.82	 objects based on conditional matching just as I would with any other programming language.
1924.46	1931.82	 Make sure it's copied and paste. So now I only have the information of the values. Sorry,
1931.82	1937.26	 the information gathered by having the, in this case, it was roll equals spine. So we can do a
1937.26	1940.9399999999998	 lot of complex manipulations of our data structures ahead of time without having to guess and check.
1941.6599999999999	1948.78	 Now the one thing that I do want to touch on is, oh, this right here. So two other things actually.
1949.42	1955.58	 Where I said that it's not a REPL. So in this case, I would expect a normal programming language.
1955.58	1962.3	 Remember I had that variable called leafs defined. It's an empty map. I would expect that if this
1962.3	1966.94	 was a REPL, I've created that variable, I've initialized it, I should be able to store something
1966.94	1970.06	 there, right? That's how it would work in Python. I create the variable and I can store something.
1970.86	1977.02	 In this case, I have that command that says store the output of what I did before,
1977.66	1983.18	 but store it as the value called leafs. So I can reference that map later on. If I try to do that,
1985.26	1989.58	 it fails. So it's not a full-blown REPL. So you have to work through your data manipulation
1989.58	1995.42	 in the correct way based on the console, but you can't actually store the variables. You've
1995.42	1999.9	 got to do that in your code like I had in the previous example. Do the manipulation and then
1999.9	2006.1399999999999	 query the variable afterwards. And then finally, you can also do some text manipulation. In this
2006.14	2012.0600000000002	 case, I'm just throwing demo in front of a value here. So I have, I remember that list,
2012.0600000000002	2016.3000000000002	 we had VRFA and VRFB. I've given them new names, demo VRFA and demo VRFB.
2018.7800000000002	2024.14	 Sweet. Okay. Let's get out of the console here. Now finally, oops.
2026.22	2030.94	 Let's talk about abstraction. How many folks have worked with Ansible and Ansible roles before?
2030.94	2036.38	 They simplify a lot of things, right? Where you can say, let's hide all the complex underneath.
2036.38	2040.54	 Let's only present a few variables that we want someone to modify and edit in order to build an
2040.54	2045.5	 entire fleet of something or maybe a whole engine X server or whatever. So Terraform has something
2045.5	2050.54	 similar. They're called modules and it does the same thing. It provides a simplification and
2050.54	2056.94	 abstraction of a configuration. Now what's important about this is every project directory.
2056.94	2062.2200000000003	 So every, in this case, this is an example I use for when I teach Terraform and ACI.
2063.1	2068.86	 01, 02, 03, 04, each of those could be considered a module, even though they're only a single level.
2069.42	2074.14	 So it can get a little weird the way that Hashtecorp references it, but every project
2074.14	2078.7000000000003	 directory is a module in the eyes of Terraform because it's going to take, if I was to nest any
2078.7000000000003	2082.94	 folder or any other Terraform file underneath these, it would collapse those all up into one
2082.94	2091.42	 and perform the automation. Which is why, so like I said, within a root module, all Terraform files
2091.42	2095.58	 are analyzed and interpreted, interpolated even in subfolders. So because of that, we can build
2095.58	2100.46	 the concept of a module very easily. Unlike an Ansible, we have to have a specific roles directory
2100.46	2106.2200000000003	 defined in our Ansible CFG. By default, everything inside of a Terraform directory
2107.02	2113.98	 is considered, you know, fair, fair game to be able to use. So in this case, I have the sub
2113.98	2121.3399999999997	 submodule folder where I have a main.tf, an outputs.tf, a variables.tf. When I run Terraform plan
2121.3399999999997	2128.14	 on the top level main.tf, it will take in everything from that submodule and present that northbound,
2128.14	2134.06	 so all that automation is included. This way we can do a lot of our routines in that submodule piece.
2134.14	2139.1	 We can define our outputs of what we want things to look like and we can abstract. So only main.tf
2139.1	2142.86	 is something that's very simple and is very foolproof, you should say.
2145.2599999999998	2151.9	 Now Terraform has a really good set of instructions on when to build modules. This is kind of a
2151.9	2156.2999999999997	 distillation of that. If you want to simplify your configuration, so maybe do a lot of repetition.
2156.2999999999997	2159.98	 The same thing over and over and over again. In my example, I'm building ACI tenants.
2160.62	2164.22	 All the same stuff, we know we're going to change some variable names for the top level tenant,
2164.22	2169.26	 but maybe we want our VRF, our bridge domain, and things like that to follow along that same pattern.
2169.26	2172.86	 So we don't want to have someone modifying all those different variables. Let's just build a
2172.86	2178.62	 module, feed it one name, feed it a subnet IP, and we're good to go. You can prevent configuration
2178.62	2181.98	 issues. So if you do something, like I said, if you do something a lot or you have like a VPN that
2181.98	2186.62	 you want to build as part of something, the VPN configuration can be hidden away inside of a module,
2186.62	2191.3399999999997	 and so you only have to deal with the top level tenants and things like that. Then the reuse of
2191.3399999999997	2198.22	 configuration. So let me get in here. Yep, eight minutes left. Let's show you how this works. So
2198.22	2207.02	 in this 06 modules folder, I have this ACI tenant folder. So I have this 06 modules and I have a
2207.02	2212.38	 folder called modules, and under that I have this ACI tenant. I have a main.tf,
2212.38	2223.42	 which defines the provider I'm going to use. In this case, it's ACI. How to connect to that ACI
2223.42	2230.06	 fabric and then how to build the things that I want. In this case, it's a tenant, a VRF, a bridge
2230.06	2239.42	 domain, and a subnet. Now you notice here, I have a reference to a specific variable. Now in Terraform,
2239.82	2246.46	 if I have something with a dollar sign ensconced by the curly braces, that's variable interpolation.
2247.02	2252.86	 So that says instead of referencing that variable directly, get the name of that variable and stick
2252.86	2259.34	 it in there. So if I have a variable called aardvark, it would be aardvark-vrf. And I like to
2259.34	2263.5	 use the word aardvark because it's fun to say, but it also shows up at the top of ACI. It's a AA,
2263.5	2268.62	 so it shows up at the very top of my ACI fabric. So I interpret each of those variables and fill
2268.62	2274.7	 that name into this specific string for each one of those things. And you can see how I built my
2274.7	2281.02	 automation. So I'm always referencing that tenant name and just changing the suffix after that. So
2281.02	2286.38	 bridge domain, things like that. And then I have a specific one for my cedar block.
2288.62	2293.8199999999997	 My variables, I've just hidden away my, and I'm going to copy this because I know my fabric is
2293.82	2299.82	 timed out. I built in variables, so in this case it's just the ACI always on sandbox within DevNet.
2300.86	2305.1800000000003	 And I've defined, because it's Go and I have to initialize the structures ahead of time,
2305.1800000000003	2311.42	 I've just defined blank variables for tenant, vrf, and bridge domain, and subnet. So there's
2311.42	2315.6600000000003	 no values there. I haven't set a default argument, but I've just initialized those variables so they
2315.6600000000003	2321.42	 can be accessed by Terraform. And then finally, I have an output. Because we want to make sure
2321.42	2326.7000000000003	 that our automation behaves the way we expect it to, I defined two output variables inside this
2326.7000000000003	2334.78	 output.tf. In this case, name of the vrf and the name of the bridge domain. And those directly
2334.78	2346.7000000000003	 reference the values that were here in this main.tf. Clear so far? Now on the top level project,
2346.7	2352.7	 I have a main.tf where I'm just using this, oh I'm sorry, the module is actually called
2352.7	2360.7	 ACI tenant skeleton. Missed that one there. So I have this module and I'm using the source as
2360.7	2364.9399999999996	 the ACI tenant skeleton folder. So read in the Terraform files from there and treat it as a module.
2366.62	2372.06	 I define my tenant name, the variable that I defined earlier, var.tenant.name. In this case,
2372.06	2379.98	 I've just called it aardvark1. And I defined a cedar block, 1010.1.0.0.1. So I'm creating a
2379.98	2386.46	 tenant as I would normally with Terraform, but all I have done is reference a tenant name and a
2386.46	2390.94	 cedar block because the module is automating everything else. Remember I built the vrf,
2390.94	2394.54	 the bridge domain based on the tenant name, all that's been hidden away by the module.
2396.54	2401.2599999999998	 I have a variables.tf with nothing in it, so there's nothing on my sleeve here, no trickery.
2402.7	2409.9	 And my outputs.tf, I have the vrf name and the bridge domain name printed on the output of my
2409.9	2418.38	 Terraform run. Now you notice the one difference here is instead of referencing the outputs directly,
2419.02	2424.54	 I reference them as a child of the module. So module instead of output dot whatever,
2425.2599999999998	2431.98	 aci-tenant-scaffold, which is the name that I assigned to the module, and then dot bd.
2433.02	2437.2599999999998	 And same with vrf. So I can reference those outputs and they will show up at the end of my Terraform
2437.2599999999998	2453.82	 run. So scrolling up here, and let's do a Terraform init. The one thing I will say is that
2453.82	2461.5800000000004	 because I'm using a non-standard provider, you have to reference the provider both in
2461.5800000000004	2465.98	 both main.tfs essentially. You have to reference it in the module and reference it in the
2467.26	2472.46	 the top level project as well. Otherwise you'll say looking for hashcorp-aci and it will fail.
2472.46	2478.54	 So you've got to reference that name there. So we've done an init. Let's do a Terraform plan,
2478.54	2489.66	 out tf.plan. And you can see it is built or it is planned everything based on the outputs that
2489.66	2495.1	 I've given it. So we have the cedar block there and you can see that we have the outputs,
2496.22	2500.3	 the bridge domain and vrf name referencing the output of the Terraform plan itself.
2500.3	2504.86	 So by assigning a tenant name and a cedar block, I've hidden away the rest of the abstraction,
2504.86	2510.06	 but an entire aci tenant would be built. And just to show you that everything is actually
2510.06	2516.46	 going to function as planned, I'm going to apply this and also jump over here.
2518.7000000000003	2525.5	 And of course I copy paste it and can't find the, oh no.
2531.34	2532.54	 This is an internet problem.
2534.86	2549.02	 I promise you this worked yesterday.
2555.58	2560.78	 Yeah, well I like to live and die by the demo. So let's go to the module here and I bet it's
2560.78	2565.5	 under main.tf. Actually, variables.tf.
2570.3	2571.42	 No, that should work.
2574.3	2582.5400000000004	 It's saying it can't log in, which probably is related to the fact that I needed this demo.
2587.34	2588.86	 Or maybe the fabric died, who knows.
2591.5	2599.5	 All right, I promise you under normal conditions this would work, but it's not logging in,
2599.5	2602.94	 so I'm betting that's the case. So you should be able to take this code and apply it towards
2602.94	2608.3	 a normal production fabric and everything would work. I can record a video and show you that it
2608.3	2611.5800000000004	 does work and post it in the WebEx room. But yeah, we're having some login problems. I'm
2611.5800000000004	2616.7000000000003	 willing to bet that the fabric, the always on controller died because I can't log in.
2616.7	2621.74	 Anyway, in a perfect world, we get that aardvark tenant being applied and you would be able to see
2621.74	2628.14	 it in the tenant listing there just as you would inside the plan. Yeah, something's broke.
2630.62	2636.3799999999997	 Okay, let me slide back over here. Wrapping it all up, of course I don't have the sample code here.
2636.3799999999997	2643.66	 Join the WebEx space. I will post the QR code there. I don't know why I didn't save it.
2643.8199999999997	2649.2599999999998	 Anyway, join the WebEx space. I will post the sample code. Please fill out your session surveys.
2649.2599999999998	2653.74	 I think you've formed your offer to a free t-shirt and I'll be around for the rest of the week over
2653.74	2658.14	 in the Cisco U learning and certifications booth to talk Terraform, Kubernetes, Docker,
2658.14	2660.94	 anything else that your heart desires. Thank you so much for your time.
