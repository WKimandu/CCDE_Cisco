 Welcome to Cisco Live. I hope you have a good time. Now let's make sure we're not interrupting that flow. And having said that, I also realize I'm probably the only thing standing between you and a decent dinner with either customers, partners, or friends. So let's try to make this quick. Let's try to keep this interactive. Even though we have a bigger audience, if you have questions, please feel free to raise them. Nevertheless, there is also time after the session, so I'll stay here. So if you have certain questions and you want to discuss them one to one, I'm happy to do that as well. Having said that, as you've probably heard a million times for each of those sessions, there is a dedicated Webex space that you can join. And if there is a question that arises sometime later, could be a week, could be a month, but could even be a year, feel free to use that Webex space and raise that question. I'll continue monitoring that space. So be aware. It says this room or this space is only being monitored until the 23rd of February. Let me correct that. That's certainly not true. I'll keep monitoring that space if you have questions. Now, first of all, let me introduce myself. So I'm Daniel Schmidt. I'm a principal architect within the CX or Customer Experience Organization, or more specifically, professional services. Now, what this means is that I work with customers and partners like you on a daily basis, trying to support them with implementing DC network solutions, like ACI, for example. Now, having said that, I'm likely facing similar issues as you are. So to some extent, we are in the same boat. We are fighting and we are trying to make our own delivery, deploying ACI and other solutions as efficient as possible. And that's also how it came to this solution and why we developed this in the first place. So this session is about the solution called Nexus S Code. As the name somehow implies, this is closely related to infrastructure as code. And I'm pretty sure everyone has heard about infrastructure as code already. But infrastructure as code can mean different things to different people, right? So let's start and get us all on the same page in terms of what infrastructure as code is, or what is relevant in the context of Nexus S Code. Now, we'll look at Nexus S Code, what it is, how you can use it, how you can consume it, and what it hopefully brings to the table in terms of benefits and advantages. But we'll look beyond just provisioning and managing configurations in ACI. We're looking at what else is required to fully support a change process and what else can be automated along that process. So we are looking at things like pre-change validation, things like how can we possibly also automate the testing part? And at the end, we look at how can we leverage CI-CD, which is like a common technology, a common framework known from software development. How can we take that and use it for our own purposes, right? And at the very end, we'll look at something what we call services as code, which is really like a product or a service that we as Cisco as a vendor offer to you, which goes beyond just the technical capabilities and tools that we provide. But this is more about what can we do to support you in terms of enablement, in terms of offering support for the solution, which could be technical support in terms of 24-7 support, et cetera, right? So we'll look at that as well. Now, just to give you a brief heads up, and that's probably a good example, on a lot of those slides, you will see a lot of text. Now, there is not necessarily a need for you to read through all the text. The reason I'm including the text is because if you go back to the slides later on, or maybe someone looks at the slides that was not part of the session, to make it or to provide a bit more context and hopefully make it useful as well. So, let's look at the slides. So, let's look at the slides. How many of you have heard infrastructure as code and have played with it in one way or another? So, I would say the majority probably at least at some point got in touch with infrastructure as code. Now, as said, and that's also what is being depicted here, there are different definitions of what infrastructure as code is. So, instead of reading out loud those, let me try to provide my own description. And to be very honest, the name itself as code can be intimidating, right? It can imply something like you must be a software developer to fully embrace and understand infrastructure as code. And let me make this clear, that's certainly not the case, right? So, even though it says infrastructure as code, what infrastructure as code is really about is essentially leveraging tools and processes that are well established in the software development world, right? But basically use them for our own purposes, which in our case is maintaining networks or maintaining network infrastructure. And the way we approach this is that we essentially maintain a description of how we want the infrastructure to look like, and then we are leveraging automation that ensures that this description of how the infrastructure should look like is eventually also reflected in the actual environment or actual infrastructure, right? So, that's what infrastructure as code is about. So, be aware infrastructure as code is not a single tool, it's not an application, it's rather a methodology or a process on how we can use it. So, infrastructure as code is on how we can manage infrastructure. Now, let's go one step further, or zoom out a bit, right? We as Cisco, we as a vendor, how do we provide infrastructure as code tooling to you? Now, as you're probably aware, there are different tools out there when it comes to infrastructure as code. There are tools like Terraform, there are other tools like Ansible, you might even heard of tools like Pulumi and others. Now, all of them kind of serve a similar purpose, and we are not necessarily religious about tools. So, what I mean by that is if you prefer to use Ansible, we're perfectly fine with that. If you, for whatever reason, are more familiar with Terraform, or maybe you're using Terraform already to provision public cloud infrastructure, then please use Terraform, right? So, we provide integrations for both and for all the different products. I mean, I'm specifically talking about DC networking here, but we do provide integrations for Terraform and Ansible accordingly. Now, on top of those, there's typically a concept where you can abstract certain functionality into a single unit that makes it easier to consume. So, in Terraform, we call this a Terraform module. The equivalent in Ansible would be an Ansible role. So, for example, for Terraform, we provide modules that allow you to configure specific parts of the ECI configuration. So, think of an L3 out in ECI as an example, right? So, instead of having to configure all the individual objects and resources individually, you can use that single module that hopefully simplifies the consumption of those. Now, once you have those modules and Ansible roles in place, what you need to provide typically in case of Terraform is a Terraform configuration, which is typically written in a language called HCL, or the equivalent on the Ansible side would be an Ansible playbook, which is typically or is always being written in YAML, right? And then, on top of that, you need to provide some data, right? You need to provide data in terms of what do you actually want to be configured? How many tenants do you want to be configured? How many EPG's? How many bridge domains? How do you want to name them, etc., etc.? Now, where does Nexus S code fit in this diagram? It's actually everything that you see encircled by this green line, right? So, what we are trying to do with Nexus S code is essentially make infrastructure as code as simple and as easy to consume as possible, right? Because we realize, and as we've seen here, there's a bunch of people that have heard and have maybe played with infrastructure as code, but nevertheless, there is a considerable barrier of entry in terms of truly adopting this, and not only in a lab or kind of development environment, but fully embracing this in a production environment, right? So, what we want to achieve with Nexus S code is really make this easier, lower the barrier of entry, and really make it as simple to use as possible, while still providing all the benefits that infrastructure as code in general brings to the table, right? Okay. Nexus S code itself relies on Terraform. So, we use Terraform to provision the infrastructure, in our case, ACI. Now, be aware, this session is not about teaching you Terraform. We use Terraform as a tool underneath, but we also realize that Terraform can be quite complex. So, for those of you who have played with Terraform already, when it comes to complex configuration, it's important when it comes to complex configuration, it's not a simple thing to use. So, Nexus S code attempts to abstract this away from you, not, you don't necessarily need to become a Terraform expert to use Nexus S code. We want to make this easier to use for you. Now, at the same time, we need to understand what Terraform does and how it works, right? So, what you see on the right-hand side is a typical Terraform configuration, which shows you how you can configure a simple VLAN pool with a certain set of, or a single VLAN range within that pool, right? And this very much looks like code, right? If you look at this, this can be, looks a bit similar to code. There's certain logic in it, not maybe in this example, but if it becomes more complex, then you would make, then you would need to make use of loops and similar constructs, right? Now, going back to what Terraform does, Terraform is really a tool to provision infrastructure, but not only as a one-off thing to just push configuration, push and forget. It's more than that because it's a tool that allows you to continuously maintain a configuration. Now, what this means is Terraform actually keeps track of the state of the infrastructure, so it knows exactly how it left the infrastructure the last time Terraform was executed and is able to detect configuration drift, meaning if there's an out-of-band change that happens outside of Terraform, so someone maybe logs into the UI, changes something that was initially configured through Terraform, Terraform is able to detect that configuration drift and is able to eventually reconcile that configuration drift if necessary. Now, another thing that is also important, there are two distinct operations in Terraform. One is called the Terraform plan operation and think of a Terraform plan as a dry run, so it doesn't yet apply any changes to your actual infrastructure, so what it does, it actually simulates what changes would need to be applied, what is the list of operations that I would need to go through in order to apply the desired configuration to the infrastructure. And the second one is the Terraform apply operation, so this is where we now take that previously calculated list of operations and actually apply to the infrastructure, but these are two distinct operations, so that means you can do one without the other. So, coming back to Nexus code, so as said, Nexus code is really about making infrastructure code as simple to consume as possible, so there are certain things or certain data that obviously you need to provide, right? We don't know how many tenants, how many bridge domains, how many VRFs you want to configure, so that's data that you need to provide, but you shouldn't be the one that should deal with writing and configuring, so that's data that you need to provide, but you shouldn't be the one that should deal with writing the actual code in order to implement that, so what we want to do is you provide the data, we provide all the logic, all the implementation that is necessary to eventually deploy the configuration according to your description, and it's something simple, as you can see on the right-hand side, right? The important part is, and that's where we come back to the as code aspect, as code essentially means we want to maintain this as something that is text based, that is human readable, because in the end it's us, the human, that is actually maintaining and modifying that configuration, but at the same time it should also be machine readable, which essentially means it should follow a certain structure, it should be structured data, right? Now, let's take a look at how this is different compared to using Terraform natively. Again, on the left-hand side, this is how you would configure a tenant with two VRFs using native Terraform, and this is a bit more complex than what we've seen before, because you can see something like a foreach, which is essentially a looping construct within Terraform. Now, think of a full-scale production configuration with potentially a different production configuration, with potentially hundreds of VRFs, hundreds of bridge domains, EPGs, contracts, filters, etc. You can imagine that configuration like this can become quite complex. Now, compare this to what you need with Nexus as code. It's purely a description of how you want ACI to be configured, a tenant with a specific name and a list of VRFs. That's it, right? You don't need to think about in which order do I need to configure these objects, right? Do I need to configure the tenant before the VRF, which is kind of obvious, right? But there are other relations which are not that obvious. Now, a more concrete example. Everyone familiar with ACI knows that when you add a new node to ACI, there are certain configurations that you need to apply. I mean, first of all, you need to register the node itself, right? You need to tell the EP controller which node, which serial number potentially do you want to register, and what is the role of that particular node. But then there are a bunch of other configurations in all kind of different places in the UI that you would typically need to apply, right? Think of an out-of-band management IP address that's not configured where you actually apply or register the node. That's configured in the management tenant. Or if you want to apply something like a fabric policy group or fabric policy configuration, again, that's a completely different place in the UI. Not only the UI, even the object tree and the object configuration. So the way we approach this with Nexus S Code is that every configuration that is being applied at the node level is being grouped into a single section, right? So what you can see on the right hand side is a list of nodes and all the configuration that is typically being applied at the node level. Now let me briefly explain why this makes a difference. Let's assume we want to add a new node to our environment. We install a new leaf, right? And we want to apply the according configuration to that leaf. Now what this means with Nexus S Code is we simply take the existing configuration, like the configuration we have for this node 101 as an example, and it becomes a simple copy-paste exercise. And then we're just updating the relevant values like IP addresses, serial number, node IDs, et cetera. That's it, right? We don't need to jump between different places in the UI. We don't need to jump between different configuration sections, et cetera. So that's one of the concepts we try to follow with Nexus S Code. We're always having, again, I said I'm working in professional services. So I'm facing the exact same challenges with ECI as you are, right? So this is being built with operations in mind. We want to make sure that this is not a one-off thing to configure ECI, configure and forget. This is really meant to operate a full ECI environment. Let me give you another example. I guess you're familiar with access policy configuration when it comes to configuring interfaces, server-facing interfaces. If you do this from scratch, it can be quite complicated and tedious. And it's not only that. There are a bunch of different ways of how this can be done. Think of all the profiles and selectors, how you set them up initially, how you connect them to each other. Now, we want to abstract this away from you, right? There are certain best practices that we learned as professional services when we've been deploying some of the largest ECI deployments. We don't want everyone to deal with understanding what is the best practice to configure those access policies, right? What is important for you is provide data in terms of which interface do you want to configure how, which effectively means define the physical interface and apply a corresponding interface policy group or configuration template, in other words, to it. Everything else shouldn't be of concern to you, right? And that's how this is being dealt with in Nexus code. You just provide a list, as you can see on the right-hand side, which interface is supposed to be used for what, and all the underlying objects, like the profiles, selectors, et cetera, are being managed by Nexus code. All right. So these have been two examples of how a certain part of the configuration looks like, right? Now, let's take a look at a simple example where we have a very simple tenant configuration, and I will walk you through how this tenant configuration can be applied to an ACI environment. I'm using Visual Studio Code in this demonstration, right? In this case, I'm using a prerecorded video just in order to allow me to talk and explain things while this video is playing, right? So what you see here, and I'll open this on the left-hand side, is a single file that describes a very simple tenant configuration. So a tenant with a few bridge domains, a few VLANs. That's it. Now, consider this a greenfield environment. So there's nothing deployed in ACI yet. So what we will do next, we'll go to the command line and just type terraform apply. Now, what this does, and let me just briefly pause here. What this does is now create that terraform plan, which as we said before is a dry run. So it gives you a list of operations that terraform would now apply to the, would is important, would apply to the infrastructure in order to apply the desired state to the ACI environment, right? So what this comes down to is a list of objects, because that's how the configuration ACI is built, a list of objects that terraform would push to ACI. Now, we can review this. Someone who has a good knowledge of ACI can verify that this is really in line with our intended change. And it then asks the question of whether we want to apply that configuration, which is what we are doing here, right? We are typing yes, which is nothing more than giving the green light to deploying the actual configuration. And if we go to the APIC, we can see that all the objects that we have previously defined in the YAML file are now deployed in the ACI or on the APIC controller, right? Now, what we will do next is we'll go to one of those objects, more specifically an EPG that has been configured by terraform. And what we'll do here is we'll change a specific setting, right? So there is this preferred group membership attribute that can be configured. We're going to change that from exclude to include. So we are basically applying an out of band change. And we are running terraform apply again. And what terraform notices at this point is that apparently there has been a change outside of terraform. So it understands that this specific setting of an EPG that is managed by terraform has changed. And it would now reconciled, meaning go back to the desired configuration for this specific attribute, right? So that's what we see in the plan output here. So we would go from include back to exclude because that's what we have in our terraform configuration. Now, an important aspect, and that's again, that goes back to how we build or how we intended to build Nexus code in the first place. We want to make sure that you only need to provide the data, which is what you see on the left hand side. And the terraform configuration that you need, I mean, you need some terraform configuration, obviously, to make use of terraform. So we want to make sure that you only need to provide the data, which is what you see on the left hand side. But that configuration should really be minimal and completely static, which is what you see on the right hand side. And this is not shortened in any way. This is really those, I don't know, 10 lines of terraform configuration. This is everything that you need, right? And as I said, this is completely static. You don't need to touch that. The only thing that you would modify is essentially the YAML files that you would see on the left hand side. And this is an important aspect, right? Because if you want to run this in a production environment, you want to make sure that the code and the actual data is being managed separately, right? The data is something that the network operator is potentially updating on a daily basis. The code shouldn't, right? The code should remain static, should be tested thoroughly. There should be a release lifecycle, etc. Now, let's maybe look a bit under the hood in terms of how Nexus S Code works. So as we've seen before, we essentially expose Nexus S Code as a single terraform module. So instead of you having to write all the terraform code, you just need to call that single module and provide those YAML files as input. Now, under the hood, there are certain abstractions where we essentially need to translate the code into a single terraform module. Under the hood, there are certain abstractions where we essentially need to translate the input from your YAML files into the respective ECI objects that we eventually need to push to the ECI infrastructure. And that's where all the logic and all the complexity lies. But the idea is that's something that we want to maintain in a single place and every one of you to be able to consume without worrying about testing this on a continuous basis. So the blue boxes that you see here, these are what are typically objects in ECI, right? So if we take an EPG as an example, there is obviously the EPG object itself, but then there are a bunch of child objects that you would typically manage as well. Things like the domain association or things potentially subnets that are configured under the EPG. Now, the way this is handled in Nexus S Code is that we essentially, first of all, build a bunch of modules to first of all abstract and simplify that configuration. But it goes a step further, as we've seen before, because we don't want you to deal with multiple modules and potential dependencies between those. We again take those modules, and these are like 100 plus modules. We take those modules and again abstract them and combine them into a single module, as we've seen before. Within Nexus S Code, we make use of something called configuration areas. It's not necessarily an all or nothing approach. It means it doesn't mean Nexus S Code needs to manage your full ECI configuration no matter what. You can use Nexus S Code in a way that you can say, I just want to manage that single tenant initially with Nexus S Code. But all the access policies and fabric policies configuration, that's maybe still maintained manually or through some other automation. So we introduce those kind of configuration areas or six type of configuration areas, which are the ones that are listed on the top. And you can individually enable and disable them, depending on how much of the ECI configuration you want to manage with Nexus S Code. Now, assuming you want to use Nexus S Code with a full scale configuration, right? Think of hundreds of tenants, potentially hundreds of leaves being deployed in a single fabric. You don't necessarily want to put all that definition or YAML text into a single file, right? Having a single file with 10,000s of lines of text is difficult to manage. So you want to split that configuration into manageable pieces. And the way we approach this, we want to provide you full freedom in terms of how you can do this. And it very much depends on the actual deployment, right? So in an SP environment where you potentially have hundreds of tenants, it might make sense to manage each tenant individually in a single YAML file, right? There might also be cases where you have a lot of configuration in a single tenant. So you might necessarily want to have that all in a single file. So you can split this further into individual files. The whole idea is we don't want to dictate how this structure or how you structure your YAML files. Nexus Code actually doesn't care how many YAML files you provide, right? What Nexus Code does internally is essentially takes all the YAML files that you provided, combines that into a single data structure, and that's what Nexus Code then uses going forward, right? So whether your configuration is split into 1,000 YAML files or everything is included into a free file, it doesn't really matter to Nexus Code. Let me provide you an example how that merge works, right? So as I said before, you might be in a situation where a lot of configuration is applied within a single tenant. Now you might want to divide that configuration further into, as I said before, manageable pieces. Now how can this be done? You can, for example, divide the configuration into a single file, right? So we can have a tenant, a single tenant called brought, and within that tenant we have a service deployed for management purposes, right? Which consists of a VRF and a bunch of other objects associated to that VRF. So you can divide that configuration into multiple pieces. So you can divide that configuration into multiple pieces. So you can divide that configuration into multiple pieces. And as I said, you might want to manage for management purposes, right? Which consists of a VRF and a bunch of other objects associated to that VRF. So we can manage that single service in a single YAML file, but then within that very same tenant, we can have another service like an HR service as an example. But you want to manage that in a completely different YAML file. That might be due to different administrative domains, right? Different people managing different parts of the configuration. But that might also be simply due to the fact that we want to ease maintenance of the actual configuration. Now, in some cases, you have to deal with sensitive information. If you think of a full ECI configuration, you might want to configure something like BGP passwords, right? And you might not want to include that sensitive information in clear text in your YAML files, because that effectively means everyone who has access to those YAML files can immediately see those values. So the way we can deal with this in Nexus S Code is we can work with so-called placeholders. And we essentially use placeholders for or make use of environment variables. So instead of putting the actual value in the YAML file, we can put a reference there to an environment variable. And during runtime, we evaluate the value of this environment variable and dynamically insert it into the configuration accordingly. Now, this is typically how you deal with secrets in a CI-CD environment or CI-CD platform, right? So to give you an example, a CI-CD environment like GitHub or GitLab would be another example. Jenkins typically provides some way of storing secrets. So it allows you to define those secrets, store them, confidentialize them, store them confidentially, and dynamically insert or inject them during runtime. So whenever you run the code, essentially the Terraform apply operation, the CI-CD platform will take the value configured for the specific secret and essentially create an environment variable with that value. And Nexus S Code will take the value and insert it dynamically instead of that placeholder that we see, right? So this is how it looks at runtime. So in this way, we don't need to expose this sensitive information directly in those YAML files, but instead can dynamically inject that during runtime. Now you've seen that simple configuration for a tenant, a few bridge domains, EPGs. Now imagine you want to configure something more complex in L3R. There is so much you can configure on L3R, whether it's different routing protocols, et cetera. So where do you go if you want to understand how does Nexus S Code expect that data or YAML files to look like? This is the place to go, right? So cisco.com slash go slash Nexus S Code. This will essentially take you to a Cisco DefNet page hosted on cisco.com. And it will have all the reference documentation of all the possible objects, all the possible attributes that you can configure for or within Nexus S Code. And it's not only that, it's a reference documentation, but it also provides you readily usable examples that you can simply take, copy, paste into your configuration, adapt, and use. On top of that, it's not only a reference documentation, but it also provides, as I said before, examples, but also step-by-step tutorials on how to get started with Nexus S Code. So if you want to learn more, go to that link. It's also included at the very end of the presentation. This has all the relevant documentation that exists for Nexus S Code. Now, something we've been working on recently is also making the user or improving the user experience around maintaining those YAML files. So we've developed an integration with Visual Studio Code that essentially allows you or provides you things like tooltips. You begin start typing T-E-N, and it suggests that there is a tenant's object that you can configure. And not only that, it also lists all the possible values that you can configure within a tenant. I'm not sure why it's not... Okay. It also offers things like auto-completion, right? For example, as we will see next, we're going to configure a bridge domain, and as we auto-complete the bridge domain, it immediately tells us that you need to configure a name and a VRF. It also does validation as you type, meaning if you provide a value that is out of range, it will immediately tell you that there is an error in the configuration, and you can fix the error right away, right? Now, what do you need for this? You need Visual Studio Code, obviously. You need to install a single extension, which is the YAML extension, and you need to name your files accordingly, which is the .nac.yaml extension. Once you have that extension, Visual Studio Code understands that this is supposed to be configured according to the Nexus Code data model and immediately runs those validations against your data as you type, right? Coming back to using this in production, for obvious reasons, you want to keep your configuration as lean as possible, because whenever you repeat something, that's a possible place where you can introduce errors. You want to avoid that. So, within Nexus Code, there's a concept of default values. We try to provide default values, meaningful default values, as much as possible, right? But in some cases, a default value that works for one deployment isn't necessarily the best choice for another deployment. And let me give you an example. If you configure a bridge domain in ACI, that bridge domain by default has Unicast routing enabled, because likely the majority of customers use this ACI as a layer-free fabric, which makes perfect sense, right? But assume you're using ACI just as a layer-2 fabric, you would need to disable Unicast routing on each and every bridge domain, right? So, for obvious reasons, we don't want to do this for each and every bridge domain that we configure in Nexus Code. So, what we can do instead is we can actually modify that default value, set Unicast routing to false, which essentially means that we don't need to repeat that configuration for each and every object that we have, bridge domain, as an example. One last thing before we continue with other aspects than provisioning. You might be thinking that all looks nice, but do I really want to maintain all that information in a set of YAML files? It might be easy to calculate, but I don't think that's the case. So, how do we incorporate data from other sources than YAML files? So, we have a set of YAML files. We have a set of YAML files, and we have a set of YAML files that we want to incorporate into the YAML files. So, how do we incorporate data from other sources than YAML files? So, how can we incorporate data from other sources than YAML files? And I'll use a simple example here. I'm using an IPAM. I'm using Netbox specifically as an IPAM. But Netbox is more than an IPAM. It can also be used to maintain a list of VLANs, for example, that we want to maintain, right? So, assume this is a network-centric deployment where we have a bunch of VLANs, which essentially map to a single EPG and BD, and we want to maintain that list of VLANs in Netbox, right? So, assume we have that kind of data already available in Netbox. Now, what we can do, and unfortunately we don't have the time to explain all the code, but this should just give you an idea of how we can incorporate such kind of data into Nexus S code. And this is really where open-source tooling like Terraform becomes very, very powerful, right? Because it's not only us, Cisco, providing integrations for our products. It's also other vendors providing integrations, right? It's also the community to provide integrations, because all of that is open-source. So, assuming you have an IPAM like Netbox in place, there is a good chance, and in this case the answer is yes, that there is an integration that already exists either within the Terraform or Ansible ecosystem. So, the way we can use this is we can actually use that integration that already exists to pull data from Netbox, in this case just a list of VLANs, and then we use that data that we pulled from Netbox. We kind of transform the data a bit to work with our Nexus S code data model or data structures. So, we get the list of VLANs from Netbox. Based on that list of VLANs, we're going to create a list of rich domains where the name is being derived from the name that we have in Netbox. And then we're able to merge that data with the data that we have in the YAML files, right? So, we have parts of the configuration defined in the YAML file, like the tenant, like the VRFs. And then we're pulling in other data from Netbox, which essentially then creates the list of rich domains and also EPGs. Again, this should just serve as an example of how this can be done, meaning it doesn't necessarily end with those YAML files. That's just one way of providing data to Nexus S code. All right, enough of configuration management. Thinking of maintaining a huge set of YAML files, right? Think of 100 YAML files potentially with hundreds of lines of text or code. The bigger the configuration, the more complex the configuration, the bigger the chance that humans introduce errors. My point is to think about the data that we have in the YAML file. My point is there is not necessarily something that we can do to prevent human errors from happening, right? Wherever humans are interfacing with a system like ACI, there is a chance that the human introduces an error. What we can influence in one way or another is when do we potentially detect that mistake or error as it happened, right? What we want to prevent from happening is that we only detect that error once it has already been deployed in the production environment and potentially has impacted an existing deployment. That's what we want to prevent. So this is what pre-change validation is about. It's essentially a programmatic approach to validating configurations before we are deploying them in a production environment. We want to make sure that we find any kind of errors find any kind of human errors or other errors that were introduced for whatever reason before they are potentially impacting a production deployment. Now, those kind of validations can happen on different levels. And I'll explain this in a bit more detail with examples, right? So there is validation that can happen on the format level. We can validate the format of our input files like the YAML files. We can validate the syntax of those files. We can do semantic validations. And last but not least, we can also do compliance validation. Compliance is typically something rather customer-specific, right? You might have specific naming conventions in place, how you want the objects in ACI to be named. So what you can do is you can essentially define a requirement that says, this is how I want bridge domains to be named, and I want to make sure that whenever someone adds a bridge domain to our configuration, we make sure that it follows the naming convention that we set in place, again, before it's potentially deployed in our production environment. Now, let's take a closer look how that validation can work. In order to facilitate that, we've open sourced a tool called IAC Validate. It's essentially a Python-based CLI tool that supports different types of validations, essentially the ones that I've been showing before. And it's kind of purpose-built for infrastructure as code, or more specifically for Nexus as code as well. So it's essentially a tool that allows you to run validations against those YAML files on different levels, right? Syntax, semantics, compliance. Now, how does the syntax validation work as an example? It works by you or us, depending on, providing a schema that defines how the data should look like. So schema is nothing more than a definition of how the data should look like. So one example could be, you're all familiar with nodes in ACI, right? Every node in ACI has to have an ID, and that ID has to be a number within a certain range, right? It has to be between 100 and 4,000. So what we can do with syntax validation, we can define that each and every node ID must be a number within a certain range. Now, once we define this in a schema, we can continuously use that schema to validate all the YAML files on a continuous basis, right? So we can make sure that every change that we make to our YAML files, whenever someone touches a node ID, it's a number within that range. Otherwise, we'll raise a violation, and we're not allowing them to do that. So that's how such a schema should look like, or could look like. We're actually leveraging another open source tool called Yamal. That's essentially just a way of defining the structure for our YAML files, and defining some of those value constraints. Now, the other thing is semantic validation. Semantic validation is the same thing as a schema. It's basically a schema that defines the structure of the data. Now, the other thing is semantic validation. Semantic validation is really about verifying, in this case, ECI-specific constraints. So going back to this example of node IDs, the node ID not only has to be a number within a certain range, we also need to make sure that each and every node ID within a certain ECI deployment is unique, right? You cannot reuse the same node ID twice. So a very simple semantic validation rule could be, make sure that each and every node ID is unique, right? Another example of a semantic validation is verifying something known as referential integrity. So as you probably were, in ECI we're often dealing with relationships, right? So there are these parent-child relationships. BRF is part of a tenant, or is a child of a tenant. But then there are also indirect relationships, where one object in one part of the object tree is referring to another object somewhere else. Think of an EPG consuming a contract as an example. Now, what we can do with this is we can verify that each of those relationships are actually valid references, right? So typically we refer to other objects by its name. So we say EPG1 consumes the contract named HTTP as an example. So what we can do is, because we do have full knowledge of the whole configuration, we can easily verify those references are valid, right? So if you make a typo, and for example refer to a contract that doesn't exist, we can easily detect that using semantic validation. But this goes further, right? We can also verify certain best practices or how ECI needs to be configured. Now, what you essentially get as an output for these semantic validations is a set of violations, right? If you violate certain rules, then you get an error message, and you can provide that as feedback to the user, and the user can actually correct the mistake. Now there is also compliance validation. You can't build certain compliance rules into the data that you have. You can't build certain compliance rules into the tool that I've shown before, like the IEC validate tool, and there is more information on the website of that tool. But there is another kind of dedicated product that is purpose-built for running those kind of compliance checks against your infrastructure, which is Nexus Dashboard Insights, right? Now what Nexus Dashboard Insights does, think of it as a digital twin of your ECI deployment. So it creates a digital representation of your, for example, production ECI environment, and uses that digital representation to run changes against that model, and do a kind of before-after comparison to see if the proposed change that you haven't yet deployed in your production environment causes any unknown side effects or issues. So what we can do in the context of Nexus code is we can leverage that in the sense that we prepare a change in Nexus code, we take that prepared change, using a tool, push it to NDI, let NDI replicate that change on that digital twin, and do that before-after comparison to see if there are any unexpected side effects with our proposed change, right? Another CLI tool that can easily be integrated. There is more information available on that website. Last but not least, there are certain parts that we can only test or validate after deploying a certain configuration. That's specifically when it comes to operational state. So think of we are deploying an L3 out with a BGB peering to some external router, right? If we deploy that configuration, we would expect that this BGB peering is in an upstate afterwards. But obviously we can only verify that once we've deployed the actual configuration. So the way we can approach this is by automating the testing and making sure that whenever we apply changes to our ECI environment, we run certain tests in an automated way to make sure that the operational state afterwards is as we would expect it to be. Now there are different kinds of things that we can verify. One of them is operational state as mentioned. Another thing we can do with ECI is ECI already collects a lot of telemetry, right? It correlates that, it aggregates that, it kind of provides something known as faults and health scores as an example. So what we can do with ECI, we can pull those health scores, we can pull those faults and either compare them against a certain threshold. So we can say, okay, if our health score for the tenant that we just configured dropped below 90, that's something we want to know about. Or we can also do such as I said before, before after comparison, right? We can pull the faults that we had before applying the change, do the same afterwards, and then see if there are any faults that got reintroduced or got introduced because of our change. Because if that's the case, we probably want to know about this, right? Another tool for this purpose, which is called IEC test, which is essentially, unfortunately we can't go into the details, but there are some more hidden slides included in this deck. So if you download the slides, there's some additional information available there on how such tests can be incorporated and included, right? And we'll also show you an example how that works in a second. Now, last thing I want to touch on is CI-CD. It's a difficult topic because it actually originates from software development. But think of it essentially as a workflow engine, something that allows you to trigger certain workflows as you make changes to your YAML files. And the way this works is that you put those YAML files into a Git repository. So that Git repository effectively becomes your source of truth for configuration data. And then you have a CI-CD platform that listens to changes in that repository and triggers certain workflows, right? How could such a workflow look like or what workflows could that put in place? One example is being shown here. So we've seen those validations, syntactic semantic compliance validations. So one thing we can do is that we can set up a workflow that whenever we make changes in that repository, we automatically run those validations and provide feedback via a Webex notification as an example to the user. Another workflow could be if we open a pull request. Now, this is something very specific to Git or GitHub. It's essentially the intent to eventually merge that change into our main branch or production environment. So this is right before we deploy the actual change. Now, in this stage, we might do some more comprehensive validation and testing. Things like this NDI pre-change validation. The reason we want to do this here is because it can be quite intensive in terms of resources and time required, right? So we don't necessarily want to do this for every change, but rather when we come closer to merging that change into our production environment. And the third one is the one that gets triggered once we merge into the main branch, which effectively means that's when we want to deploy the configuration. So this time it's about deploying the configuration, running the post implementation testing that we briefly discussed before, and again, provide feedback to the user whether the deployment has been successful, whether the testing has been successful. Let me run you through a quick demo. Similar setup as before, right? So we have a set of user profiles. So we have a set of YAML files describing a simple tenant configuration, much like as we've seen before. Now the first thing that we're doing here is we're creating a new branch. We want to prepare the change in a kind of isolated environment. We don't necessarily want to apply changes directly to our production environment. So what we're going to do here is, as you can see, there's a bunch of EPGs and BDs already configured. So what we're going to do here is we simply add a new EPG and bridge them into the configuration. So we take the configuration of an existing EPG and bridge domain, we simply copy-paste it and update the values accordingly. What we will do next is we'll commit those changes to the central Git repository, right? So everyone is working against the central repository. We are doing the same. We're committing them against that or to that repository. As we do that, what we will see next is that as we are committing to the central repository, essentially applying a change, the first workflow that we've seen before gets triggered, which is about validation. So we want to make sure that the changes that we triggered are being validated. And that's what's happening here. And we're actually receiving a Webex notification that says the validation has failed. And it also provides us a bit more context in terms of why it has failed. It says there is a subnet overlap. Now, if we go back to the configuration, we can actually see I intentionally did a mistake here, right? I configured two bridge domains with overlapping subnets. Now, this is likely something that you would easily see if you look at a small configuration like this. But again, think of hundreds of bridge domains that's probably close to impossible to detect such mistakes up front, right? So that's where validation comes into play. Before we have deployed anything to our production environment, we're able to detect that mistake and correct it so that it doesn't impact our environment. We fixed the mistake. We pushed it again. We again triggered the exact same workflow running the validations, except that this time we expect it to be successful. And indeed, we receive the Webex notification which says validation has been successful. So what we can do now, we can continue on to the next step, which is opening the pull request, which is our intent to merge that change and eventually deploy it. So this is the point where others in my team can maybe review that change, right? They can go through the changes that I did and they can review and verify that this is indeed in line with the intended change. Now, as we do that, we can see there's another workflow that has been triggered, which is like the second workflow that we've seen before, right? Now, this time what we will see is that we are not running the NDI validation because that would take a lot of time and we don't have the time today, right? But what we will see is that we will essentially do a Terraform plan, a try run, and we'll paste the output from the Terraform plan directly here in the pull request in GitHub. So we can see exactly these are the changes that Terraform intends to apply to the infrastructure. And the very last step now is where we are going to apply those changes, right? So we have someone that reviewed that change, that potentially approved that change, and we can now go ahead and apply that change, which is exactly what is happening now. We are merging it, right? We are putting that change into place and we are eventually deploying that configuration. This is the workflow that is now being triggered for the deployment. So this is where the Terraform apply operation is being executed. But it's not only that, it's also the testing, as we've seen before, that will be executed here. Now, as a result, it just takes a second until we get the response for this. We again receive a Webex notification that tells us whether the deployment was successful or not. And in addition to that, we just have to wait a few seconds. We also get the summary of the testing. So how many tests did we execute? How many of those have passed? How many of those have been successful? Which is what we see here, right? That's just a summary. If we want to know more, we can click on this testing link and it will take us directly to the test report. This slide is just for reference because I've continuously heard the question of, that looks nice for ACI, but what about the NDO? What about if you manage your configuration with NDO? We do support NDO configurations with Nexus S Code as well. Very similar or the exact same approach, right? You provide the same configuration with NDO, but you have to have a different configuration. Very similar or the exact same approach, right? You provide a set of YAML files describing it and Nexus S Code manages the rest. Last slide. I know this has been a lot of content. And just to make sure that I'm not confusing anyone, everything that you've seen so far is open source and freely available to everyone, right? So there's absolutely nothing wrong with taking what we've published, taking the open source tooling, using it yourself and doing this in a more or less do-it-yourself fashion. But we've also seen that there are customers that are looking to get support from the vendor or us in that case, right? And this is where we have this services as code offer in place, which is essentially a subscriptional offer where we support you in terms of enablement, where we are also supporting you in terms of developing maybe specific features that you require in your environment, but where we can also provide technical support on a 24-7 basis, right? So if you run into issues with the solution, you can open a case with us like you would do with any TAC, right? And you can get hold of an engineer and we'll work with you on fixing that issue, right? Again, this is completely optional, but it's something just to be aware of. All right, that's it, right? There are a bunch of references here in terms of links, how you can get started with this and some additional information. Feel free to check out those. And as I said before, there are some additional slides being included, which I've not shown here. So if you're interested to learn more, feel free to check out the slides. And as I said before, if there are any questions, please feel free to raise them in the Webex space. All right.