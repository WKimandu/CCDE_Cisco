 So here's what we're going to cover today for the next 90 minutes plus. We're going to talk a little bit about what infrastructure as code is, right? We're going to briefly sort of describe what we think infrastructure as code is. Then we're going to get into infrastructure as code with Ansible and Raf is going to cover that portion of that. Then we're going to come back to me. I'm going to talk about infrastructure as code with Terraform and then we'll talk about next steps. Where do we go from here based on some of the information that you heard about in today's session? Well, what is infrastructure as code? A lot of people like to define what infrastructure as code is, right? Simply, it's management and provisioning of computer resources or computer networks through code and data structures instead of through CLI commands. Now our friends on the cloud side and even some of our friends on the server side already are doing this. They're already leveraging infrastructure as code tools like Ansible and Terraform. However, now with things like the... ACI REST API and the ability to use infrastructure as code tools like Ansible and Terraform, now we as networking folks can start to look at leveraging those tools as well. Because traditionally, network operators, obviously, we looked at CLI and as Raf mentioned, finger net, configuring things by going through a CLI in order to configure those. In some cases, we may use an application in order to provision whatever infrastructure or configurations we want to push out there. Now, as mentioned, their new automation tools using Ansible and Terraform also allow us to define and configure and provision our infrastructure and our environment. And infrastructure as code tools define an intended state. What do we want the state of our infrastructure to look like with some of these automation tools that we'll be talking about today? And some of those automation tools are as follows. You have some that are SCI-based. You have some that are SCM or source control management. Some of the more popular ones such as Git, GitHub, GitLab, BitBucket. There may be others that you're using in your own environment. And then you have some pipeline for CI CD as well. Some of the more popular ones are Jenkins, Drone, CircleCI, and others. And then you have the execution software, what you're actually going to write your infrastructure as code in. Now, as you can see, there's a ton of options for infrastructure as code tools, right? But two of the more popular ones that we're obviously going to be talking about today and two of the more popular ones that you'll probably see out there are Ansible and Terraform. And certainly they're the most popular with customers like yourselves that are looking at moving into automation for their ACI and multi-site environments. Now in an ideal environment, this is where the end goal, where we ultimately want to be, right? We usually want a user. It could be yourself. It could be engineers on your team to submit any code to some type of source control management environment. Now again, that could be Git, could be GitHub, any number of those. That would get actually pushed out to some CI CD tool, right? Would notice that there's been a change that's been pushed out to our source control management repository, right? It would pick that up. And it would actually. It would actually do some actions based on the infrastructure, based on that code that we've defined. And then an execution runner would actually trigger the automation tool that we want to use. So in this case, it would trigger something like Ansible, would trigger something like Terraform. It could even trigger something like Python and Go, but we're not covering that in those sessions because Ansible and Terraform are probably the most popular tools, especially with folks like yourselves. Who are more coming from a network background. A networking background. But you don't really have programming experience. So really, how can you leverage these kinds of automation tools when you don't necessarily have programming experience itself? Now one of the most popular tools for infrastructure as code is Ansible, and Raf is actually going to cover Ansible. Cool. So what is Ansible? Ansible. I'm pretty sure everybody here is very familiar with it. You've heard the terminology about it. At the end of the day, its origins comes back from these in Linux. Its focus has been in automation to help provision and accelerate changes to Linux networks. So configuring things inside of boxes like Nginx or HTTP. What we've done in the side of the Cisco community now is start leveraging Ansible as a mechanism for us to configure network devices. And one of those is ACI. And ACI, of course, has the advantage of it being a very, very programmatic enabled environment because of its RESTful API. So a couple of the important aspects of it is that it is an agentless system. And all the connections and program is going to happen directly from your computer that you're using today. So you can use it to talk to the ACI fabric. OK? The other part that I wanted to kind of key into, because I think this is important, and I want to mention something because this is something I saw actually today. In the breakfast with the other speakers, I sat at a table with a group of speakers just like, no, attendees just like yourself, and talking a little about this. And I think there's a challenge, right, that you all face. They ask you to automate, automate, automate. And I think that's a challenge. And at the same time, it's like, no BGP, no OSBF, VXLan, VPN. The plate is huge. And a programmer can focus purely on programming, but that network engineer has to focus on the outcome, which is to have a network that's operational. And for us, the advantage of Ansible for you is it takes away the need of learning to code. All that you're going to need to learn is a little bit about data science. And that's the key. And that is kind of the very key and good elements that we have in regards to utilizing Ansible or Terraform, for that matter, to do the job. So what makes up Ansible? Well, the cool thing about it is you can run it almost anywhere. I know. His laptop has been running it. My laptop has been running it. We have servers that run it. We're on everywhere. But there's many different structures that make it possible. So you can run it from right out of the automation platform, which is the most optimal way to do it. A lot of capabilities that Red Hat has built into to make you execute it. Again, all the way down, if you want to go upstream for that, is AWX, which is the open source version of Red Hat AP. All the way down to your machine. The one area that I would say is going to be Windows. Personally, I would just fire up a virtual machine with Linux and run it inside instead of trying to deal with that virtualization that Windows created for their platform. So what goes on top of that is Ansible's core elements. As you see in this, it'll be as a foundation, a Python environment that will have in itself the core and then the modules that are part of the collection system. And I'm going to go a little bit into that. What you do after that, or you layer on top of that, is what you call the core. This is what you want, the intent of how you want to put the network together. This is a part that you work with. The other stuff, somebody else coded for you. You don't need to know about how to do a request library or something to the REST interface. You don't. You specify things, what you want in this layer. And then the last part of what's needed is, of course, the targets. This is going to be your 14 ACI Fab or 16 ACI Fab. Whatever you have is the capability to do. So that's the core. Okay? So installing Ansible. This is the first question I imagine everybody has. How do I install Ansible? You can buy it from Red Hat. You can get it directly from the Internet through the open source community in PyPy. It's very simple to install. Okay? There's nothing much to it. But as everything, there's a but. To do it correctly. You definitely do not want to skip on some of these nuances there. The first thing that we talk about here is the use of virtual environments. Now, I could spend the next hour and a half talking about virtual environments and how to get it set up correctly. But I'm pretty sure you guys would be like, hey, I want to know how this works with ACI. But if you download the slide where the next slide after this does include an explanation of how to use Pyenv. Okay? Okay. So I'm going to show you a recommended way that I have for you guys to do it because you get two things with that, a virtual environment for Ansible and also the capability of selecting the specific version of Python that you want to utilize in your system. So for example, if you want to use, you know that it works with 3.9.10 and with a specific package, you get both of them combined with Pyenv. So there's an explanation right after this slide. Download the PDF and you should get it. Okay? But the reason that this is very important. I want to emphasize this. Is this gives you the ability to set up specific versions of everything that you want to be able to run Ansible. Okay? Because once you figure it out and you have it working, you kind of want to say, look, I want to repeat this again and again. And now you have that kind of like version control of all the elements that are in there that you know is going to work. Okay? All right. So what are the best practices here? There's two ways to install Ansible. You can pip install Ansible on your system and install everything. It'll download Ansible and install all the modules. Everything will come through in one shot. Or you install core and you selectively then install the different collections. I recommend that part because it gives you the ability again to selectively know which versions of these collections you want to use. Okay? That you know are going to work. Instead of just telling Ansible, hey, bring everything down. Okay? So, raf, what are you talking about? What is collections? What is this? What is this thing that you're talking about? So. One question for you, and when you say install in a virtual environment, you're just talking about in a container or in a, you know, use a VM, a Linux VM? Very good question. This question is when I'm talking about installing a virtual environment, I'm talking about a a virtual machine, a container, or whatever it is. You can have it inside a container, you won't be, you don't have to. A virtual environment is a individual structure specific to a directory. You can specify it that way. So it's not a virtual, it could be a virtual machine and you can put it inside of that virtual machine, create a virtual environment, or you can have it be in your machine, your laptop, if you have a Linux box, you can set it up there, it doesn't matter. Usually in container land, we don't use them inside of the container. Inside of the container, we build the container with all the specifics that we need for it to run Ansible inside of the Docker file. And then that container becomes, in essence, a virtual environment. But you can have in your laptop, for example, hundreds of virtual environments, all available to you. You can have one that says, hey, Ansible 2.3, Ansible 2.3, whatever you want. You can put them on your laptop, you can put them all in, okay? All right, so what are collections? Collections are what Ansible created to deal with the situation of multi-vendors having their code embedded in Ansible. Before, it used to be like Ansible was on a schedule of releases, and Cisco and every vendor had to align to those releases. That, of course, doesn't work too well, right? Because if we wanted to release something tied to a release, a release of ACI, I'm pretty sure Red Hat's not gonna be like, oh, wait for Cisco, no. So what they did is they created a modular system that allows us to install modules on our own terms, and every vendor now utilizes the system, which is fantastic, because now we have our own cadence and mechanism of release and cut. So I've included here two URLs in the bottom to show you guys those collection URLs and where they are. You can go see them, and each of the individuals, you can see the individual releases that are out there, okay? So here's another very important page. Save this one down. If I'm working with a customer entering stuff, this probably page is there all the time. I don't know if Thomas' feels like the same. You have this thing up and you're looking all the time. This is the list of the modules that are part of the collection, okay? This is the Bible. Everything is here. If you wanted to know how, let's say, a bridge domain is gonna be built in these thing, in the modules, you can go click on it. It gives you every parameter. It gives you examples. It gives you everything. So it's really good information right there. So these modules are used by tasks, and I'm gonna start using some of this terminology so you can start stacking this information in your head and start seeing how all these elements are going to connect to each other, because I think it's important to understand what everything does. But these modules, what they do is they specify an action or a task that's gonna be completed. So if we look at the one that we have here, right, we have one that's doing a bridge domain. So the module name is ACIBD, and it has a full namespace reference. And you can see in this where you have different parameters, like the VIRF, the bridge domain type, the name, ARP flooding, L2 and NUNUniCAT. So if you've done any ACI, these are standard things that you're very well aware of, and you have to define for every bridge domain that you put out. So the advantage, I mean, if you see this, do you feel that you need to know programming for this? What do you guys think? This is doable, right? We're not doing crazy things. Yeah, question. So can I fix it from a spreadsheet, a CSV? Yes. You can. There are modules that, excuse me, Raf, there's a specific module around read CSV that I not turn my mic back on. It's, I don't know if he's got, it's called read underscore CSV, and that will actually read in comma separated values from a CSV file if you so choose. So yes. So a lot of the modules that Raf is talking about here with ACI, and there are a ton of them, you're not just limited to just these. You can leverage things like read CSV, so you can read in those values to maybe replace some of the configuration there. And the beautiful thing, and he'll talk about variables, is you can really start to not only make your playbooks repeatable, but really start to scale up your configurations. Yes. Yeah. So you can tell an answerable to read the CSV, but you can't just say, oh, I'm not going to read this. I'm going to read the CSV instead of have to write this scripted. It's not our code. There's a module to read CSV that you just tell the module, like, hey, read this CSV, and it's going to read it, and it's going to place everything where it belongs. Yes. Sorry, question. What would you use for an editor? We're going to get to that. I'm loving you guys, by the way. We presented this session in Europe, and we had no questions. Yeah, you guys are awesome. All right. So I wanted to show this. Again, I just want to show this so you guys can see. This is simple. This is not hard. It's not a mountain to climb here. It's a fairly easy process. All right. So let's talk a little bit about concepts and answerables. So first one that I want to talk to you guys is specifically around the directory structure. I've been burned by this. Start in the right way. Take this slide, look at it, and say, this is the way to go. Just start there, even if you're not totally comfortable with it, but it's a great place to start. And it'll let you grow. Because one of the things that happens if you end up with a bunch of playbooks and one directory and things connected, it will get out of hand fast. And then it's hard for you to manage growth in Fabrics. And I can tell you, for example, like one of the last customers that I worked with, we ended up with, so like 25,000 lines of YAML. Okay? Remember, this is ACI. You can get an L3 out with BGP and have, you know, 100 BGP peers there and suddenly, you know, this configuration could get gnarly. Okay? All right. So what do we use? Answer to your question. You're not going to use Word. No? No? Get that out. All right? You need to utilize an editor for programmers. You need something that's going to give you the ability to help you in doing this. A good YAML and YAML linter. So linters are a way for an ID to tell you, hey, you're doing something wrong. Okay? We'll actually guide you along the way and say, hey, this is incorrectly configured or there's something wrong. You didn't indent this correctly. I don't understand what you're doing. Okay? Really valuable. So I list a couple here. This is not an exclusive list. This is what we could fit inside of the deck. Very common one right now is VS Code. It's free. It's open source. You can download it and run it on your laptop. It's fantastic. I use it all the time. Other ones like ATOM, PyCharm has a community version and also has a for pay version. It has PyCharm, I will say from a perspective of Python, is insanely powerful. And then you have Eclipse and no plus plus even does it, but limited. Okay? These are some of the tools you use. Personally, VS Code and Atom is a great place to start. All right. So what is an answerable role? And this is starting now getting into the new way of Ansible doing things, but a role is a way for you to establish a collection of tasks that are going to complete a task, something that you want to do. So let's say you want to define an L3 out. Anybody here configured L3 outs in ACI? How much steps is that? Quite a few, right? So what you can do is you can actually bundle everything inside of one. Roll and say the role is to make an L3 out and then it will have the capacity. You pass the information into it and it's able to do it. Or you can make it as simple as, hey, I want to have a role that's make a VLAN pool. So it's up to you guys to define how you want it to be structured. Does that make sense? Okay. Then we move into Playbooks and I'm pretty sure everybody's heard Playbooks mentioned somewhere in this industry. I got a Playbook for this, I got a Playbook for that. You know, Playbook, Playbooks, Playbook, Playbooks. But at the end of the way that I want you guys to understand, Playbooks is a way where you're going to start connecting things. You're going to connect roles to inventories, to variables. It's kind of like the central place for you to establish what is it that you want to do. But if you create them correctly, then suddenly, you have the ability to do a lot of reuse. And this is key. And I'm going to show you guys a little bit about this. All right. Ansel Inventory. Who are you going to do it to? Probably this is a little bit different than what you guys were expecting to see, correct? Huh? Is everybody here that done read inventory files with INI? Yes? Yeah? The typical way that I've seen everybody do it is with the INI format. But a better way to do it is with the YAML format. And this here is saying, in this case, you're going to see this a lot, is East Fabric. And then it's going to be like the variables that are there, which is admin, username, and password, and then the host. And this is the Fabric IP. I'm showing you this for simplicity so you understand. But please never put your username and password inside of your code. All right? Just please don't. Because if you go into Git land and you do a commit with that username and that password, you're going to spend the next five hours with somebody that knows Git really, really well trying to get it out of the, expunge it from the repository. Okay? The best way to do it is to utilize environment variables. And then they'll just be, that information will just exist as an environment variable there. The better, better, better, better way is to use Vaults. But beyond the scope of this. All right. Another huge part of Ansible is going to be Jinja. The Jinja template system is the one that actually is used to fill in variables inside of things. It's a templating system. So I know if you've worked with things before in programmability, templates are used to substitute. It's an easy way to print code, put a data in there, get a structure through it. At the end, you have something. Okay? Now, we use this extensively in Ansible. And what I wanted for you guys to see is if I defined this name here, username, and value is John, and then I come down here and say username, and I say, hey, this is going to be username. In the end, when it runs, it's going to substitute this section here with John. Okay? All right. So we're doing it all together. First thing is we take, as I mentioned earlier, we had the East fabric defined inside of the playbook. And what it's done is gone read the inventory to see, get the username, the password for it there. The next part is going to be to say, hey, we got a role that we're going to do access policy VLANs, and it's going to go find it and say, hey, that is the task that's involved in access policy VLANs. And then it starts connecting the data. It's going to be in the dots, right? You'll see that it has now username password, the inventory host name, which is matches from the other side. And it's just connecting everything together. So once that's done, execution. And here you'll see what it looks like. We're invoking the Ansible playbook. We ask the inventory file to be the East fabric. We run it and boom, off it goes. And Ansible says right here that it made the change. OK? Any questions? So let's go into the details that are related to ACI. So first things first on this list, you will see something that says gather facts, and it's set to false. OK? And connection is local. Why is that? This is a very important thing to understand. When Ansible runs against a Linux box, Ansible transports itself into the box. So to know what it's connecting to and know what it's going to do, it gathers facts. Like it goes there and looks around and says, oh, this is all the details. And then it knows what it needs to do to work with that particular version of Linux. But for ACI, we won't do that, right? In ACI, we're not going to connect to the box and do all these things. For ACI, what we're going to do is we're going to interact with ACI's REST interface. So the connection is going to be, OK, we're going to connect to the box. The connection is we will never gather facts, and the connection is local. So if you run it from your laptop, that laptop is actually connecting to the ACI fabric directly. Does this make sense? OK. And then outside of that, I've included some here for you guys for references, in or errors, falses. And these are just ways for you to, if you want to see the playbooks end, if there's a problem or if you're just like, I'm just testing. I just want it to keep going, right? Whatever. And then the role. OK? So those tasks that are in those roles are going to contain, as we showed earlier, let's just follow this example. So ACI VLAN pool. That is going to be the module that we're going to use. So we're going to make a task that's called Create Engineering VLAN Pool. And then here we have, hey, the username, the password, all that stuff. And then we say, hey, the pool is going to be called, and it's VLAN pool. OK? And then pool allocation mode is going to be defined as static. You all know this part from, easy part from ACI. And then the description. Then we need to specify the state. Here we're going to say it's present, meaning that we want it. If we were to delete it, we would say absent. OK? And that's kind of very important decisions that you're going to start seeing with between Terraform, and Ansible. OK? The other part here that's important is validate certs as no, use SSL as no. That is just depending. If your Fabric has valid certs, woo-hoo. If you don't, then you're probably going to do a self sign, and you're just going to use those in. Make sense? OK? And then the bottom part, delegate to local host. Why is that? Because we're going to run it on our own machine that we're running right now. OK? All right. Authentication. I did hear somebody say they had version 3 ACI out there. So if you are in version 3 and version 4 of ACI, you're going to have to go and utilize the right side, the certificate base. The reason for that is because ACI would see the repeat of connections coming from Ansible as a denial of service attack for the username. So inside of ACI 3 and 4, the username, and passwords were restricted to x amount of connections per minute. This changed in ACI 5. In ACI 5 and ACI 6, it became an option. You can turn it on if you want to, whatever. Certificate base just bypasses it, because it just connects to the API via the certificate system. And then it directly goes through. So if 3 and 4, you're going to need to use the bottom. OK? As I mentioned earlier, you can utilize the left side with username, password, and use environment variables as a method. OK? To authenticate. Best possible way is vaults. All right. Last part of this is the rest modules. And the rest modules gives you as a fallback mode that if the module doesn't exist in ACI, then it allows you to configure directly through JSON objects to push into the fabric whatever is not available through the module. So the Ansible and the Terraform modules both give you the ability to configure everything in ACI. If the module's not there, you can get the object in. OK? All right. Let's go through an example. This is what I call an unoptimal mode. In an unoptimal mode, we've sat down and we've coded one. We call the task, create engineering VLAN pool. And then we go in and we say the pool, and we call it. We put everything specific. Now, if you wanted to create 100 VLAN pools, you would now have to create 100 one of these guys. Right? Each one an individual task that you do for each one. There's a better way. The better way to do it is to utilizing lists and lists of objects or dictionaries, if you want to call it Python. And this is just saying, hey, I'm just going to go ahead and I'll keep adding here definitions of different VLAN pools in this list. And then when you do that, what happens is it gives you the ability now for us to run this through iterative mode. So what is this iterative mode magic? So if you can see here, this is the iterative mode magic. So if you can see here in the bottom, there's a little thing. It says loop. OK? And that loop is pointing to VLAN pools as a variable. And it's going up here to VLAN pools here. OK? And then that guy has a list. We have four of them right here. Four different elements in this list. The four objects. Those four objects, we want to iterate through. Right? We're just going to use the same task, go through the variables, ding, ding, ding, ding, ding, and configure. So what we do is we use this concept of item. So down here, inside of this object, that item element is going to reference each element in that list. And then after that, item dot the name of the variable. See? You guys following me? Did I lose you? We good? Cool. So now what happens is, we're going to do this. As we go through doing this, and someone is going to say, oh, I'm going to go through that list. And it is going to now iterate through it and end up with, guess what? Four VLAN pools. Right? And again, I made this example super easy, so it's easy to understand. Right? I know your ACI fabrics are not this way, but you get the concepts. Right? Here are the four of them that have been created. You can substitute that variable definition there, and you can tell Ansible to do the exact same thing with the CSV. And it'll just read it and run it. Do you have to structure the header of the CSV? Absolutely. Absolutely. It's very easy. We do this all the time with CSV. Some customers ask us to do a CSV. We have them. I think there's a way to do it with Excel, too. There's so many ways that are out there to do it. It's documented what their names of them are supposed to be over there? For what different objects? Yep. Cool. So in the main.yaml under roles, would there be bars under roles? They would be multiple. I can't VLAN pools, but later down on the file, you would have something else for the next thing you wanted to do. And so depending on which playbook you're running, which one it will grab. OK. So the question is, if I have different things or whatever that you want to do, and the name in there, it's going to read it. And I'll show you guys a little bit trick about this. But this variable there, Ansible is going to read and find. There cannot be two named VLAN pools, two variables named VLAN pools around in different places. You have one of them. Because if not, it's going to be like, wait, wait, wait. What are you doing? There's two of them. OK. But we can have VLAN pools in two different fabrics, right? And we're going to organize it in a little bit. We're going to use it to do that. All right. So if you have VLAN pools and ETGs in that same file, and it creates both of them? Yeah. Yeah. OK. You can have one file that has 200,000 lines in it. I would highly, highly recommend not doing that. So I think, for example, VLAN pools should be in one file. Ansible will go into a directory we're going to specify. And he's going to read all of the files first. He's going to put everything in memory. And then he's going to run. So even if you say csv. It gets loaded first. OK. All right. So a word about variables. So here there's a folder called group vars. And again, back to what I was structure I was telling you about, how important this is. Because what it's going to allow us is to group the way that is going to allow us to group the way that these variables all are going to be read by the system. Because why? You might have, how much is it? 16 fabrics? 16 fabrics. You might not going to have those variables all broken apart, right? They're not going to be one. Your VLAN pools for one fabric makes sense. But for 16, you want to have 16 places, right? So what do we do? We move these variables away from those tasks into the group vars. And the group vars, we organize them via the host names that we've defined. So if I do this really quick, I go up here, I create a playbook. OK. I get somebody that says, hey, it's EaseFabric access policies. He's going to go in and look in group vars, and he's going to find EaseFabric. EaseFabric now has all these definitions of different files. And he's just going to read them all in one . If you ran the playbook and you had a lot of stuff in it, the first thing you're going to see is Ansible, like, reading, reading, reading, reading, everything into memory. And then after it reads it, then it's able to execute the task. with the variables that have defined yes yes question is if I have the same variable name in two different parts under the same directory will error out the answer is yes because it's seen two things now a thing in the end what's going to happen is it's going to read the last one at red so it might be even worse for you because it might not error out it might just go and say okay read that again rep substitute it over here this is the last one I read and which one it read last you want to guess which one I have no idea my suggestion to you would be definitely don't do that okay all right so putting it all together here it is the work of art look how fantastic this is what a beauty all put together now so what do we have we have group bars on the top or defined for an East fabric okay we have the role defined for that we have the playbook that's calling the East fabric and and the roles and the inventory and when we put it all together now what we get is the execution of ansible in a beautifully structured format that allows you to scale because think about it if we had 16 fabrics like the gentleman just in with he can create playbooks are distinctive to each one he says playbook for East fabric West fabric North fabric South fabric whatever it is and then those arrows you're reusing the tasks you don't have to create now tasks for each of those you're just reusing it and so the task is let's say create an L3 out you do it right it'll work the same for all of you just need different variables to see how it's going to be built and that's how it runs creates all these vion pools amazing and then the end is here you can see them being added and in ACI what's it 5 or 6 6 in ACI 6 look at these little a things we're getting creative guys you choose so you know what that means you can either have an Undertable or a terraform logo attached to that. So what do you do when you see one of these in an object? Don't mess with it. You know why? Because if somebody goes in there and runs that script again, guess what's going to happen to the changes that you made? They're going to be gone. So if you sit down in your Saturday afternoon and you're like, hey, we fixed this problem and you went and you plugged it directly and then next week and somebody comes and says, hey, we have to do this again. Run some playbook or somewhere and suddenly like, oh, network outage again. This is what we call split brain. Okay? What if the note came from Ansible? Great question. That's a great question. The question is, how does he know it came from Ansible? So there is an annotation in the objects that we've included since ACI 5 and 6 that gives us the knowledge of where it's from. Where it originated and the Ansible modules that we currently have create that annotation. So it'll show up as orchestration, Ansible orchestration, Terraform. It still does. Because the annotation itself is built as part of the ACI REST module itself. Gotcha? And that's in the newer version of the ACI code itself. In previous versions, and you'll see it when I go through my demo, it'll actually be a symbol, but it's nowhere as pretty as what RAF has up there. Yeah. And if you go inside of it, you will see in the top bar, it'll say this object has been created with Ansible warning. So we give you the indications to do. Now in a true infrastructure as code world, if you were go down that path, you definitely want to all your changes to happen, your fabrics originating from the code. So you can see that the code is based on the code base. Originated from this. Okay? And with that, pass the ball over to Thomas to cover wonderful world of Terraform. Thanks, Raf. Appreciate it. It's pretty good, huh? Ansible? Yeah. Yeah. Yeah. Certainly a lot of reasons why it has become one of the more popular infrastructure as code tools, not just in general, but especially for ACI. But I'm going to talk about another popular infrastructure as code tool called Terraform. What is Terraform? Excuse me. It is an open source infrastructure provisioning tool from HashiCorp. It runs as a single binary and it runs on many platforms. So you can run it on your Windows systems, your Mac, your Linux. Do anybody have any, does anybody have any Solaris systems in their environment still? You can actually, not at all, one person. Okay. I was like, nobody, oh, there's another one. You can actually run Terraform on Solaris if you so choose. Free BSD. Free BSD. So there are other options for you if you want to run Terraform in your environment. Terraform uses HashiCorp Configuration Language, or HCL. It is a declarative language in which you are going to use to define the infrastructure that you want Terraform to provision. It leverages the same APEC REST API calls today that you're already using through the GUI, and that Raf had kind of mentioned, as well. So it uses the same REST API interface. No programming knowledge is required because Terraform, like Ansible, abstracts the underlying Python in Ansible's case and Go in Terraform's case. It abstracts that, so you only need to know about how to structure your HCL configurations in order to use Terraform. And really, you only require data structure knowledge about the objects that you want Terraform to provision in your environment. Installing Terraform is very easy. This is just off of the Terraform website. As I've mentioned, there's many options for varying operating systems out there. In this case, you can install it on Mac here using Brew. You can actually install it using a Windows binary. So lots of options that are out there. Now, the Terraform binary is just a command line executable file, right? It doesn't know anything about ACI or AWS or anything yet. That's just... That's the binary that's going to be used to run actual Terraform itself. And let's talk about some Terraform concepts while we're on that. So Terraform has the concept of plans and configuration files. And what those are are a collection of HCL instructions to tell Terraform what you want to do and what you want to provision in your environment. It uses a .tf extension. So Terraform will actually scan a directory in which you create... create your configuration files. And it knows, because of the declarative nature of Terraform, and I'll talk about that in a moment, it knows that you want to execute and create all of those resources that you want Terraform to actually create. You can have this broken up into smaller configuration files or .tf files, or you can have it in one large main .tf file. Main .tf is what you'll see a lot in examples when you look at Terraform itself. And here you tend to structure it. It's under one directory here. So in this case, it's considered the default workspace. A workspace is where you would have all of your Terraform configurations set up and structured. And in this example here, I have my L3L configurations that I'm going to provision through Terraform all in one particular directory itself. Now, as I mentioned, Terraform... the Terraform binary itself doesn't know anything about the API calls to the APIC or the Multisite Orchestrator. It doesn't know any of that. We require providers for that. And what providers do is it allows us to create, read, update, or remove, or in Terraform vernacular, destroy infrastructure that it provisions. And it relies on specific vendor plug-ins, which are downloaded and installed via initialization. We will talk about what that process of Terraform initialization is in a moment. But Terraform providers understand those API calls. That we want to make for infrastructure. We want a provision to ACI itself. And since Terraform is an open source tool, you can actually write your own providers if you know Go, if you so choose. I do not Go, so I do not know any Go. So I don't really contribute to that. I'm more of an end user myself of Terraform. Now, there are three types of providers that are available for you. The first one is the official provider. And that is... Those are the... Those are the providers that are actually owned and maintained by HashiCorp. A couple of examples of that are the major cloud providers. AWS, GCP, Azure, and some others. So those are the ones that HashiCorp themselves owns, updates, and maintains. The second type of provider, and this is where Cisco falls in, is the partner provider. So we are a HashiCorp partner. And HashiCorp certifies our ACI and MSO providers. So this is where you would find the provider for all of the resources if you want to provision ACI and Multisite using Terraform itself. And then finally, there's a third type of provider that is available for you. That third type of provider, as you can imagine since it is open source, is the larger community. So in this case, that's published and maintained by individuals in the larger open source community. So those are the three types of providers that you would have in your environment. If you want to see more information about not only the ACI or MSO provider, but maybe all of the providers, you can check out the website at the top right of the page here, registry.terraform.io. So here's an example Terraform provider configuration for ACI. So in this case, I'm specifying in my configuration file, and this could be in my main .tf or any other type of file name with a .tf extension. Terraform doesn't care. It doesn't care exactly about the name itself. So in this case, I have my Terraform configuration itself. And here, I specify what providers I want Terraform to use. In this case, I want Terraform to use the ACI provider. And the source of that provider where Terraform is going to grab that and download it is going to be in the namespace under source Cisco DevNet ACI. Now, if you want to use Terraform, you can use the source of that provider. Now, what you don't see in here, but just know that in the background, this is what happens. When you initialize the Terraform provider, it actually goes out to registry.terraform.io under that namespace, so Cisco DevNet ACI. And that's where it goes to download the provider information that is required for Terraform to provision infrastructure. You can use versioning for Terraform providers, in this case, the ACI provider. As of this session, 2.8 is the latest. And chances are, knowing my luck, the Cisco BU, who does actively maintain both the ACI and the multi-site Terraform provider, they've probably published a new version. They did this to us in Amsterdam. So it would not surprise me if 2.8 is no longer the new version by the time you are currently watching this or by the time you go check yourselves. Here, though, I specify. . . a version of the Terraform ACI provider that I want Terraform to go out and download and use. If you do not specify a provider version, like the one listed up there, it will automatically use the most recent version. So just know that. Now, here, I actually specify my Terraform provider configuration itself. So since I wanted to use the ACI provider, now I'm going to actually configure it to use that provider itself. In this case. . . like Raf used with Ansible, we're going to use signature-based authentication or self-signed certificates. So I define a local user name. Let me see if I can get this to work here. So I define my local user name on the APIC, which you have to if you're using signature-based authentication. You have to have a local user on the APIC in order to use that. And then I also identify my private key as well as the certificate that I want Terraform to use. . . Then I also provide the APIC URL. So this is the URL with the IP address of the management interface of my APIC. So it knows the IP in which Terraform needs to push its infrastructure as code out to. And then finally, specifying insecure equals true. If we're not using SSL certificates, then we could just set that to insecure is true. And we are not using SSL certificates here. Here is an example of a. . . of using the multi-site or Nexus Dashboard Orchestrator. Just a quick show of hands. How many of you are using Nexus Dashboard Orchestrator in your environment? Okay, a few of you. This is going to be relevant for you right now, but also for a lot of you. And I'll get to that in a moment. So here I've defined that within my Terraform configuration that I want it to use the multi-site provider. So in this case, I specify the namespace where I want Terraform to go down and download. And I'm going to use the name of the plugin that it uses. And similar to what we did previously, I can specify the version. In this case, I have 0.71. The latest as of today, or the last time I checked a couple of days ago, it's 0.10.0. That's the latest one. There are some slight differences here. I'm actually using variable substitution, much like Raf mentioned, that you can use. You can use variable substitution for username and passwords. So that is certainly an option. And much like Raf mentioned with Ansible, I can actually have my username and password in my provider configuration itself. But as you can imagine, that's not very secure, right? Because it's right there and available. Similar to what we also had, we had the URL and the insecure. But here is where the focus comes in for Nexus Dashboard Orchestrator. For those of you that are unfamiliar with it, Nexus Dashboard Orchestrator is an application that lives on Nexus Dashboard. So if we are going to have Terraform provision code and infrastructure to our multi-site environment, we're going to want to put this platform equals nd. And what that does is it allows Terraform to know that I need to speak to that application that resides on a Nexus Dashboard Orchestrator. Or on a Nexus Dashboard itself. So just know if you are looking at provisioning code and infrastructure with Terraform, using the MSN. And if you are looking at a MSO provider, that you will need to do that. Terraform has a concept of data source and resources. So this is what we use to create and update and manage our infrastructure. In the case of Terraform resources, we use that. It's specific to a given provider, so ACI and MSO. And we could use that to create, update, or remove, or in Terraform vernacular, destroy. And we'll talk about what all those mean in a moment. It describes your intent for the particular infrastructure that you want to deploy in your environment. Data sources, however, allow Terraform to read information from an environment. Because maybe we want a Terraform resource to act upon information that it gathers via a data source itself. And I've got a couple of examples that will actually go through this in a bit. Also, as of this presentation, there are over 230 Terraform resources. So there are Terraform resources and data sources. And then there are 45 MSO resources and data sources. So lots of resources available to do the most common things that you would do in an ACI fabric with Terraform. Here's a Terraform resource example. So in this case, and I decided to go a little bit outside of the standard tenant example. In this case, I'm actually going to use the type of resource. And that type of resource is the ACI bulk unit. And that's called EPG to static paths. So in this case, I want to deploy static paths to multiple interfaces within an EPG in my environment. So there's actually a Terraform resource that would allow you to do that. And that's the type of resource itself. You also have the name of the resource. So this is just what I'm naming the resource for the infrastructure I'm going to provision with that resource itself. Now, Terraform and HashiCorp configuration language configuration start out with curly braces for a start of a resource block and the ending of a resource block itself. Right? Terraform is a stateful application. So when you provision infrastructure with Terraform, it tracks the state of that infrastructure you provision in your environment. And that's where it's a big difference between Terraform and Ansible is that Terraform knows about the state of any infrastructure that you have provisioned with it. Why is this going to be important? When you store state file information, we'll talk about that in a couple of slides. It is going to use the type of resource and the name of the resource in order to do that. And you will see that when we look at the Terraform state file itself and how it keeps that information in there. Please note that the name of the resource must be unique because it does track state and it keeps information in that state file of what it's doing. It doesn't have to be specific to what infrastructure it has provisioned. The name of the resource must be unique whenever you are leveraging a resource to provision infrastructure. Here is an example of a Terraform data source. So in this case, I would like to provision a tenant in my multi-site environment and I want to provision that across multiple sites. So in this case, I want to have Terraform use the data source for MSO site to go out and read information on the site. And I can take that information and leverage that in a resource to now provision that tenant out to both sites. So this is an example of how Terraform can read in information from the environment and actually use that and act on that to provision infrastructure in my environment itself. So that's an example of a data source. 230 resources, data sources, that's a lot. And there's a lot of resources that will pretty much cover everything that you want to do with Terraform within an ACI fabric. But it doesn't cover everything, as Raf mentioned before, in Ansible. Well, what do you do if you don't have a resource to provision some infrastructure that you want to provision with Terraform? You can use the resource called ACI REST Manage. And what that does is it allows you to manage objects via the REST API. So you can manage objects via the REST API interface, the same one that you use through the APIC GUI with no resource. Now, the big difference between ACI REST Managed and ACI REST, so there's actually two separate resources that are available to you. Previously, they just had the ACI REST resource, which would allow you to implement those API calls and work around there not being a Terraform resource available for any infrastructure you want to provision. The challenge with that was you couldn't reconcile any state information that Terraform might have for infrastructure that it has already provisioned. With the ACI REST Managed resource, it actually allows you to reconcile and know the state of infrastructure that it itself has provisioned. And then for Multisite, there is also a Multisite or MSO underscore REST in which you can also use API calls. Now, how do you gather those API calls? There are two ways you can gather those API calls. Are any of you familiar with the API inspector within the APIC? Okay, some of you are, right? You can use that to capture and see those API calls, capture them, and then structure your ACI Managed REST resource to actually provision that with Terraform. There is another way. Does anybody know how you can also capture what those API calls would be? You can. Go for it. You can use the browser or inspectors. Say that again? Most browsers have an inspect element. You can. You can actually use the browser and use an inspect element. As a matter of fact, for Multisite, that's actually the way you have to do it because there is no API inspector in Multisite. You can also right-click on an object and then click on download, and you can download the JSON or XML version of that object. And that will also allow you to get some of the API calls. So, a couple of different ways to do it. In the example that I have listed below, I needed to use this ACI REST Managed to configure a user for a particular domain within my ACI Fabric. There isn't a resource in order to do this, so I was able to capture the API calls, and based on that content, hopefully I can still do this, maybe. I can actually specify here the class name here. User domain, and then specify the content. This is very simple. We just want to specify all. So, you are no longer limited if there isn't a Terraform resource, much like if there isn't an Ansible module for what you want to provision or automate. You are no longer limited to just the resources that are available to you. Terraform has, the Terraform registry has extensive documentation, both on ACI as well as on Multisite. So, here you can find out more information about not only the ACI provider itself, but you can also find out about all the resources and data sources that are available for you. But here is also the interesting thing too, as you start your journey with Terraform. It will give you more information on the individual resources, in this case the ACI application EPG, but it also gives you example code that you can use. So, you don't necessarily have to come up with the code all on your own. You can just leverage what you have here, and you can create your own infrastructure as code with Terraform. Now, in fairness, this isn't something unique to Terraform. There is extensive Ansible documentation on modules in which is the same thing. It will provide you examples, so if you want to create things, again, whether it's in Terraform or within Ansible, there is documentation for modules or resources for both. One other thing to be aware of, and unfortunately I can't say it, is that there is a lot of documentation for modules. I couldn't fit it in the slide. You have to be aware of what's mandatory. What is the mandatory configuration that this resource is going to be looking for? And by the way, same thing with Ansible. So, just keep that in mind as you start your automation journey and you're looking at using resources like this or modules like some of the ones that Raf had mentioned. There are configurations that those tools and those collections and those modules are going to expect that you have configured in your environment. Terraform is a stateful application, as I mentioned before. It will keep and track information on the state that it provisions in your environment. And it tracks and keeps that in a Terraform state file or a Terraform.tf state file if you track it locally. When you run Terraform locally on your system, it generates a Terraform.tf state file that is local to your system. So you can actually see the state of the infrastructure that you're running. And you can see that it is provisioned. Now, there's one challenge with that. That's normally okay as you're starting your journey. If I wanted to provision infrastructure in my environment using Terraform, but maybe Raf comes along, as he does sometimes, and he needs to make an update to my infrastructure, guess what the problem is? The problem is that state file is locally on my system, and I can't share that with Raf. And I only like to share some things with him. But still, if I need to share that with him or share that maybe with someone else, I can. But if I want to share that with him, right, he's on my team, I can't do that, right? So that's why it has the concepts of a backend. And there are several backends that you can use, remote, AWS. Terraform Cloud is HashiCorp's orchestrator for Terraform, so you can use any one of those. But back to the structure of Terraform state files, okay? Remember we configured previously in a couple of slides ago that ACI bulk EPG to static path? Did I get that right? Sometimes I always mess up the name of the resource. So here is where that information that I provisioned before, this is where it shows up. That's how Terraform knows about the infrastructure that we provisioned and that resource that we had up here before, right? It also includes information on the details around the interfaces and the EPGs, so it collects and stores the state of that infrastructure that it has provisioned with Terraform. Now, caveat. You cannot and you should not and you must not modify the state file directly. Do not modify the state file. If you need to make changes to your infrastructure through Terraform, they should be made through your Terraform configuration files, those TF files that I mentioned before. You can and you should make those changes to those resources directly there. Do not make changes to your Terraform state file. Question? I mean, I've run into this problem all the time with Terraform and Azure where we get config drift because somebody made changes to Azure and we modify the state file all the time. Yeah. So is it different with ACI? It's not different. So the question is he was using his experience from Azure, right, and config drift where sometimes they've had to modify the state file. Let me rephrase what I said before. It becomes a question of, can you modify your state file? Yes. Yes. You can, right? You can. Should you? Probably not because, and as you're probably experienced, you don't know what the consequences of making those kinds of changes. And I think sometimes it can make a problem, as you probably have seen, it can easily exacerbate a problem. So I think when I say don't modify the state file, I'm not saying that you can't because it's locked down via some permissions. I'm just, to avoid some of the experiences you're having, I'm trying to make sure that I steer folks that are new there. So with ACI, can we prevent them from making changes and force them to go either Terraform or Azure? So the question is, can we use Terraform or can we use ACI to prevent, people from making changes in the fabric and only use them, you know, have them only use Terraform in that case? Raf kind of ran over here, so I'm going to let him give his opinion first. He clearly is very passionate about it. And if I have, I may have something to add to that, but I'm going to let Raf go first. It's interesting. I'll say this. This is one of those fundamental things that we run when we try to talk customers, right? So some of the ways that customers, have done it is to remove the admin right capabilities of operators. Then they no longer have a chance. Now it's kind of a brutal, you know, approach. And it does have the side effect of removing some of the troubleshooting capabilities that you have because like things like ACI Diag, FMB Read and stuff, suddenly not become available to the operator. Now I have made a request into the BE now that we wanted the capability that if I push something into the ACI, that there would be some flag at part of policies to say if it is pushed, that it becomes unmutable to the user interface. You cannot change it. It's a request I put in. I'm seeing how if I can make it go through and get it done because for the people that are trying or doing stuff with infrastructure as code, the source of truth has to be the Git repository. It has to be the code. That's where you want to go. If you have people making changes after the fact, then suddenly you cannot use that source of truth anymore. It just breaks everything. So we'll see how this progresses. I'm trying to get more customers to bend around my request to get that capability added. And if we do then that would be awesome because then it would be like when you see the little symbol, don't change. Yeah. And you can probably structure your roles. And like Raf mentioned, you don't give access to the admin user. I also think just to build on what he said, and by the way, if Raf can't get that feature, to be you to implement that feature, really nobody can. I will also say that it is a mentality. Some of us, and I include myself in that us, are just so used to being able to jumping on a box, making our changes to whether it's just, oh, I'll just do it myself. So it is a mindset that may be harder to change because now we should be leveraging these tools in order to make those changes to our infrastructure. So part of it is also a mindset too because we can only take this so far. Yes, you have a question. . Okay. So, yeah, I get this question every Cisco Live and I say to myself I'm going to put a slide in there and then I don't and one day I'm going to. Okay. The question was what happens if you need to make an update, right, because of an issue you need to modify infrastructure and provision with Terraform. Well, ideally you would make that change in Terraform. You would make that change in Terraform, right? Just as much as you would in Ansible because you want to make sure, as the gentleman here mentioned, you don't want necessarily any config drift. Depending on that change that you make, okay, you will have to do some, you will have to reconcile that configuration that maybe you configured through the APIC itself with what Terraform has. And depending on the object that you've updated, right, and this is, you may have to do some things within Terraform to import. For those of you that may not be familiar, Terraform has an import capability where you can go out and import configurations into your environment. So you may have to do something around that. First off, you'll have to make sure that Terraform has the necessary configuration. You'll have to make sure that you have the necessary configurations to support those updates because the last thing you want to do is run Terraform and destroy those updates that you made out into the system, right? So you have to reconcile that. You may need to use something like Terraform import, but you also have to make sure that your resources are updated to make sure that it has those configurations in there. Yes? . Yeah. . So Terraform import, and I'll talk about the Terraform import, and then Raf, if you want to talk about the Ansible side. Terraform import is more of a tool, because here's the challenge, right? When we are looking at Greenfield deployments, right, well, I'm going to use those with Terraform. So we're using this with Terraform day one, and that's great, right? I'm building all my infrastructure with Terraform. This is great. Well, what happens if you have an existing ACI fabric that you now, with infrastructure already configured, tenants, EPGs, what if you want to use that? What if you want Terraform to now manage that? And this is where Terraform, you have to use something like Terraform import to actually do that. The challenge with Terraform import is that you can only import one object at a time. Now, let's say, for example, in his case, he had to create a new EPG, or he had to modify a contract to get whatever was broken working, right? That's easy. But if you want to import, let's say, for example, an entire tenant and all those child objects, that becomes a lot less trivial. So, to your question, could you use Terraform import to reconcile, you know, reconcile any changes before you do any pushes? You probably could, but that's probably a lot more, and especially if you're talking about a child object that's below a parent object, that's where it may become a lot more challenging. Well, I mean, I hate to say it, but a lot of times it's quicker to do things than to do it, i.e. change a port speed. It is. And to go back into tangible or going to Terraform or even Python scripting. So, let me say this right, and we need to move on to a little bit here, but the idea is, the intention of when you're going infrastructure as code is that that's the source of truth. If the source of, if you go into the GUI and you start making changes, you're not thinking that that's your source of truth anymore. And if you do that, you run into a situation now like you're going back to the old ways, right? You're going back to the mentality that my configuration is at the network. It's not in the source control. So, it's a, this is, it is a process. Aggregating the code from the network, you're saying the code is now not to be . Exactly. Like for example, in my lab, I have my whole topology for lab, having a Cisco lab is define this out of network. I can go to the APIC right now, blow it away, come back in 10 minutes, it's configured. It doesn't matter. I don't care. So, again, this is a process thing that you have to adopt and the things that, that's why it's a little bit difficult for some implementation, but it's a really cool one. Yes. I just want to mention that this is one of these web, not just web, but you would run a Terraform on a regular basis to make sure that there are no changes and basically that you need no changes on this data. You could. You could. And there are customers right now that utilize that as a security mechanism. So, for example, they run it and they say, don't, like for example, you can tell Ansible, go run and just check. If it's not what is defined, all alarms go off. Like, why? Right. So, that's, let's keep going. Yeah. So, I'd love to talk to you more about it after. So, maybe if, I have a lot of things to say. Oh, you do? Okay. I have a nice thing to say. Am I going to, are you saying that I'm going to be here for a little while after the presentation? Yeah. I would love to answer all of your questions. So, here's the interesting thing about Terraform. Terraform uses a declarative model, right? It keeps track of state file, but guess what it also does? It knows all the dependencies for ACI objects in your environment. And it actually builds a graph of that relation, those relationships. So, it knows that tenants have a relationship to application profiles, have a relationship to, to verfs and bridge domains, and that verfs and bridge domains have a relationship with each other. So, it actually builds a graph of those relationships using a directional tree without loops. And that's one of the interesting things. And in this case, I've got my ACI bridge domain resource here. So, if I bring this up here, you can see when I configure my ACI bridge domain here that I actually specify the tenant that my bridge domain is under, as well as the relationship or the association of that bridge domain to the verf. The other interesting thing about Terraform is it's not procedural, it's declarative. I can tell Terraform, these are my configurations. And because of the declarative nature of Terraform, it will figure out the order of operations in order to provision that infrastructure. And that also makes it a little bit slightly, slightly different than what Ansible does. So, you can tell it, I, you know, in so many configurations and in no particular order, I want to provision this infrastructure, it will go out and provision that infrastructure for you. You don't necessarily have to tell it what to do and in what order. Terraform actually figures that out. In this case, you could see a little bit more where I've defined those associated relationships between the ACI bridge domain and other objects like verfs and tenants themselves. Terraform supports variables and different variable types. It supports string, number, bool, as well as a list. By default, if you don't specify any variable type, it will use any. So, we'll just assume that you want to use or can use any type of variable with your variable declaration. And you can define it in an external file, or you could call it with the dash var, a dash var file, when you run your Terraform configuration. We'll show you that in a moment, running Terraform configurations. You can define that in a variables.tf file, or you can define it in a Terraform.tf vars file. So, what is a tf vars file? It allows you to separate the data from the variable declaration. So, maybe, for example, I want to give Raph the ability to provision his own infrastructure. I can give him that Terraform.tf vars file. He can update that, and we can run that and provision that through my Terraform configurations themselves. So, it allows you to separate out the data for the variables from the variables itself. In this case, this is how we define, and this is a very, very basic example of how we define variables in Terraform. In this case, I've got my variable name, my L3out underscore name, and if I specify data, I'm just specifying that that default should equal CL underscore L3out. And in this case, in my actual Terraform configuration itself, you can see where I'm actually going to use that variable itself. Terraform variables are defined with a var, dot, and then variable name itself. So, that will actually do variable substitution and replace that with that CL L3out. One thing to note, I've defined in the default here what that variable should be. If you leave that blank, and when you run Terraform, Terraform will prompt you to put whatever that entry should be. So, just note that if you work with Terraform and Terraform variables. Terraform also supports iteration, much like Ansible does. So, we could create, for example, three endpoint groups or EPGs. We could create three bridge domains, right? Three individual resource declarations for bridge domains. But why would we want to do that? That's a little bit inefficient. So, in this case, there are two types of iteration we can use with Terraform. One is count. So, in this case, I can actually specify count equals three, and I can go in, and I can specify the name of my bridge domain here to be this name, and then whatever the count index is. So, in this case, it will create Web BD 1, 2, and 3, right? So, that's one way to do iteration. If we want to provision infrastructure. The other way is for each, and this actually uses a set or a map in order to provision infrastructure that way. So, the example I have on the side here, I actually have a list of variables associated with bridge domains that I want to deploy, right? So, in this case, within my resource for the ACI bridge domain here, I can actually specify here, if I can get this working correctly, my name, I can actually use each.value, so I can create a bridge domain for Web, App, and DB here. Now, because I am using this as a list, and Terraform for each wants that in a set or map, I have to, apologies, I have to use this to set to convert that information from that list to a set or map. So, just know that that's a requirement if you're going to use for each. So, those are the two types of iteration or looping that are available to you with Terraform. Terraform also has the concept of reusability with Terraform modules, and that allows us to reuse configurations in our environment. They're just self-contained configurations. You had a question? Variables, you know, with Ansible, you can, you know, list, list dictionaries. Yes. Yes. Yes. Yes. I see this, and I don't know Terraform at all. It feels limited, like, I mean, you had that loop, but it was like three items. Well, I got my items have to be items, you know what I'm saying? Yeah, so there are a lot more Terraform, there are a lot more types of variables. So, he was wondering if there are other variable types to match what Ansible does. Pretty much what Ansible can do, Terraform can do as well. It's just not shown here. I wanted to just show more of the concept than anything else. But, yeah, you're, you're not necessarily, you're not necessarily limited, or Ansible doesn't have, necessarily have any more variable types than, than Terraform does. So, you can use Terraform modules for re-usability. So, I can actually take some of my configuration, let's say, for example, I want to provision a number of tenants, and I can actually put this in a separate modules directory. And then, in my main.tf, instead of actually using the same Terraform configuration, I can actually call a module, which will reference the information in this Terraform.tf. So, we can leverage modules for re-usability of our code within Terraform itself. Please note that with Terraform modules, if you are using modules locally, you may need to re-initialize via Terraform init. So, Terraform does support the same authentication that Raf had mentioned before. You can use environment variables or variables for username and password. You can use username and password as well. And we also can use certificate-based authentication. One thing I want to note for you multi-site orchestrator or NDO users, you cannot use signature-based authentication with multi-site. That is not available for multi-site. All right, let's talk about deploying infrastructure as code. So, we want to provision our infrastructure using Terraform init, and you can't really see it up there. I guess it's cut off, but just trust me, I guess. The command is Terraform init, as you can see right there. So, in this case, I've specified my provider configuration. When I run Terraform init, it's going to go out to the Terraform registry and grab that provider configuration and download that. It will put that into a .Terraform local directory where I run this Terraform init command, and it will also create a provider lock file to lock in the provider and the provider version there. This case, if you happen to be working with other team members, the provider information that you have set up there is actually locked in. Terraform plan allows you to see what actions that Terraform is going to use. And once again, it seems like this is cut off at the top. That's okay. The command is Terraform plan. So, you can run, once you put together your Terraform configurations, you can run Terraform plan, and Terraform will show you exactly what it's going to do and what it's going to add into your environment. So, it's a great way to check that the Terraform configurations that you're going to put together are actually what you're expecting it to. Terraform apply then allows you to apply those configurations out to the target system itself. So, when you run Terraform apply, much like plan, it will scan the local directory for your configuration or your .tf files, and it will then show you what changes it's going to make in your environment. And then it will prompt you whether or not you want to move forward with it. So, different than Terraform plan, it prompts you to let you know, would you like me to provision this infrastructure or no? If you type in yes, it will then move forward and provision all of that infrastructure here. You can actually see Terraform state here. So, this is the state of all the infrastructure that Terraform has provisioned. If you say no, it won't provision any of that infrastructure. Maybe you see an error with some of your Terraform configurations that you need to correct. One additional thing with Terraform apply, you can use the auto approve, the dash auto approve, and that actually will bypass the review of what Terraform is going to do. It prompts you and you'll have to say yes, and it will automatically move ahead and provision that infrastructure in your environment. So, that's the Terraform apply command. And here is an example of provisioning a three-tier application. So, in this case, you see at the top there, I've provisioned it with Terraform. That's the annotation. And you will see that in the current version if you're running 5.2 and you use Terraform, that is what you will see in there. You see here that it lets you know this object was created by an orchestrator. So, it gives you all that information. But all this infrastructure was provisioned via Terraform, multiple Terraform.tf files. For those of you that have a lot of experience, as you can imagine, how many clicks and how many GUI windows would it have taken in order to do this? And by the way, it's the same thing with Ansible as well. You could very easily do a lot of the stuff that Terraform is doing with Ansible itself. So, here I've provisioned my three-tier application, including contracts and contract relationships itself. Another Terraform command is maybe we don't need this infrastructure anymore. I can use Terraform destroy. So, similar to Terraform apply, it scans your state file of the infrastructure that it has provisioned, and then it will remove that infrastructure. It will also prompt you whether or not you want to move forward with removing that infrastructure. And similar to Terraform apply, you can specify auto-approve where you can bypass that, but I strongly recommend that you do not because you certainly want to ensure whatever you're removing in Terraform is all that you're removing in Terraform. You can also specify with the dash target, you can look at the Terraform state file, and you can actually target specific things that you want to remove. There is another way to remove configuration in Terraform. You can comment out resources and run Terraform apply, and it will actually remove that configuration as well. Now, you've heard a lot about Ansible. You've heard a lot about Terraform. And Raf and I put this slide together to sort of compare the two tools. So, in this case, both are open source, as mentioned by both of us. Both Ansible and Terraform are open source. Both Ansible and Terraform have a big Cisco branch. They have a very active ACIBU commitment, certainly from the ACIBU. There are active ACIBU resources that are working on both Terraform and Ansible itself. The infrastructure is code type. You've got Ansible, which is a procedural language. You tell it what you want Ansible to provision, and Ansible will provision it in the order you specify. Terraform, as I've mentioned, is declarative. You tell it what the end state you want it to be, and based on your resources and your configurations, it will go out and provide you with the infrastructure that you need to provision that infrastructure as such. Terraform is stateful. Ansible is not. You can look at the number of ACI and MSO modules and resources, but again, don't look at that number and say, wow, there's so many more Terraform resources than there are Ansible modules. That's not quite the case. With Terraform, a lot of things are broken out into separate resources to do things that may be inclusive in Ansible within a single Ansible module. So it's not like the ACI BU is working more on Terraform than it is on Ansible. But still, you can see the number of modules and resources there. . So Ansible is a configuration management tool, so it is unaware of what you may have already configured with it. Okay, well, what I was asking, though, is the current state, right, of the, of the Terraform, is it a state-based state? Terraform does, yes. Yeah, Terraform does. Ansible does not. So you can provision things. You may not have provisioned things with Ansible, but if you tell Ansible to configure something through Ansible, through Ansible Playbook, it will attempt to configure that again. So it has no concept of state like Terraform does. Yeah, it doesn't. You can write your Ansible Playbooks to go out and write pretasks, checks, to do that, but it doesn't inherently carry any state information associated with that. And then two quick things, real quick. Obviously, Ansible is written in Python, Terraform in Go, and then the last one is one that customers are always interested in. Can I get tag support? Indeed, you can. But there's always a caveat, so let me explain. You can call an open attack case, but they are not going to troubleshoot your Ansible Playbook or your Terraform configurations. They will work if there's a particular problem with a resource or an Ansible module. Okay? We also opened an issue on the GitHub repository for both Terraform and Ansible.