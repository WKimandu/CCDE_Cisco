 Hello, everyone. Welcome. We are halfway through Cisco Live, so I hope you are enjoying. And I hope you are in the right session because in this session I will be talking about infrastructure as code and how we can utilize Flask with it. Let's take a quick look at our agenda today. First, I will be talking about infrastructure as code workflow. Then we will take a quick look at Ansible and Terraform basics. Then main topic, right? Flask. I will be talking about Flask and how to use it with infrastructure as code. You know, we will add it in the infrastructure as code workflow. And at the end of this session, I will be talking about two simple scenarios. So let's start with infrastructure as code workflow. And in the early days of our carrier, we only had physical appliances, right? We built, tested, and deployed the system as a whole, which means that our deployment speed was really slow. And with the introduction of virtualization, we separated virtual layer and physical layer, which means that we can create virtual machines, right? Each virtual machine will have its own deployment cycle. So deployment speed increased. And as you know, during the containers, with the coming of containers, we divided virtual machines into multiple containers. So each container will have its own deployment cycle. So overall, deployment speed even increased. As network engineers or DevOps engineers, we need to keep up with these innovations. Why? Because these deployment cycles may require network configuration, right? How can we do it? That is the real question. And in here, infrastructure as code comes into the picture. Here you can see a simple workflow for the infrastructure as code. And we have our coder here, coder, network engineer, or DevOps engineer. He or she can build the code or build the configuration by using Terraform, Ansible, Python, or other methods, right? Then this configuration will be uploaded to a version control system. As name states, version control system will manage the code, right? So if our coder or network engineer changes the code, version also be changed in the version control system. Then this version control system will notify the pipeline orchestrator or pipeline orchestrator can pull the data from the version control system. Either way, when version changes, pipeline orchestrator will deploy the configuration to the endpoint, right? And at the endpoint, this configuration will be executed. As we discussed, our coder or network engineer can build the configuration by using Terraform, Ansible, Python, or other methods, but among these, Terraform and Ansible are really popular. So let's take a quick look at both methods. Let's start with Ansible. As you know, Ansible is open source configuration management tool, and you need to write your Ansible configuration in YAML files. And you can manage a wide range of systems with it, you know, virtual machines, network devices, cloud resources, right? It's also agentless, so you don't need to install an agent at the endpoint, but there might be a Python dependency, so at the endpoint, you might need to install a Python library or Python itself, right? That is Ansible. Let's quickly check the example here. As you can see, we have Playbook, and within Playbook, we have Plays. And when I execute this Playbook, all Plays will be executed from the beginning, which means that initially, if I execute this Playbook, of course, all Plays will be executed, right? But if I execute this Playbook again, all steps will be executed again, even though there is no change. And in here, you can see a host line, right, which refers to inventory file. And in this file, I only listed two hosts, N9K1 and N9K2. So if I execute this Playbook, this Playbook will be executed towards this N9K1 and N9K2 only. So there will be no execution towards N9K3. And here, as you can see, if you want to execute Ansible, you need to use Ansible Playbook command and with your YAML file, right? And as a CLI output, you will see, of course, your Playbook, Tasks, and hosts, but most crucial part is the summary part, where you can see if your configuration is failed or if there's an unreachable host, you can see in this summary part. Let's continue with the Terraform. Terraform is really similar to Ansible. It's also open source, right, but different to YAML. Compared to Ansible, you don't need to use YAML files, but you need to write your configuration in H-Harp language, in HCL language. So there might be a learning curve there because you need to understand how to write your configuration in HCLR. And you can also manage a wide range of systems with it, you know, virtual machines, network devices, cloud resources, right? And actually, Terraform is really popular for public cloud resources. It's also agentless, so you don't need to install an agent at the endpoint. Also, you don't have Python dependencies there, but when you execute Terraform, it will require a single binary file, which is also called provider file. You need this file for interacting with endpoints. You know, Terraform needs this file. Let's see Terraform workflow together. We have our coder again. He or she will create or update code for managing the infrastructure, right? He or she will write this Terraform code in HCL language. For your initial execution, then you execute Terraform, it will install a provider file to local directory, right? Which means that if our coder executes Terraform again, there will be no installation because you already installed the provider file to local directory. This is also only for one time installation. Then Terraform will check the code and will calculate the resources to be created, right? And it's so straightforward. Then calculated resources will be deployed to the respective targets. But as I mentioned here, as you can see, resources will be calculated, right? What does this mean? After deploying these resources to the respective targets, Terraform will save the configuration to a save state file. So if our coder changes some part of the code and executes Terraform again, Terraform again will calculate the resources. Then it will compare these resources to a save state file, right? Only the difference in the code will be executed. That is the main difference between Terraform and Ansible. So when you execute Ansible, it will execute all steps from the beginning. But Terraform, it will compare your configuration with the save state file and difference in the code will be executed. Here you can see a HCL example as we discussed previously, you need to write your configuration in HCL language and there might be a learning curve because compared to YAML, it's more like code-like, right? You need to understand how to write your configuration in HCL. And for Ansible, you need to execute another command, but for Terraform, you need to execute Terraform apply command, right? For execution. And in the red text, as you can see, Terraform calculates the resources, then compares it with the save state. And it says us that one to add, zero to change, and zero to destroy. It means that our change contains only one resource and it will be deployed to the endpoint, right? And our main topic, Flask. What is Flask? Flask is a framework written in Python. You can use Flask for creating simple web applications, right? You can create a simple GUI or a simple web page, right? And on the left side, you can see a very simple, minimal application which you can write in Flask and it gives us a web page or GUI which only says web app with Python Flask, right? It's really simple. You can create your GUI using Flask. And let's add Flask into infrastructure as code workflow. Here we have user, right? He or she may not be a coder or network engineer. We are talking about end user or a common user, right? So we want to, for example, let's say that we want to give him or her a limited capability to change the configuration. So we can just create a Flask page which may contain a text box or a button, you know? And this user may change, for example, VLAN assignment or interface speed, right? We can just give a limited capability to our common users. Then this user will select what to do from this predefined options. So this user will be limited to those options. Then based on the request, related function will be called and executed. But behind the curtain, workflow is the same, right? We have our coder, network engineer or DevOps engineer who will build the configuration by using Terraform, Ansible, Python, whatever you imagine. Then this code or configuration will be uploaded to version control system and version control system will notify the pipeline orchestrator. So all workflows are the same. What we are doing is just adding this Flask page for our common users, right? It's really simple. And why we are doing this? Because as I mentioned or as we discussed previously, our network engineers or DevOps engineers need to have both networking knowledge and coding knowledge, right? But we cannot expect the same from our end users. They may not know coding or even networking. That's why our networking team are getting lots of geratricutes or requests from these users. If you can upload some of this stuff to end users, then it will be really beneficial for our teams. For example, let's say on the left side, we are seeing a repetitive test scenario, right? In here, I'm just showing this for interface speed change or getting the interface speed of the end user. So this is a fabric. But as I'm using API calls here, you can use whatever you want because systems currently supporting API, all the systems. And on the right side, as we were discussing, I'm talking about infrastructure as code scenario. Users can either use Terraform or Ansible for creating or deleting a tenant, right? So you can upload this kind of stuff to end users. Actually, let's see the source code of the right scenario, automation scenario. We have only four buttons, right? Deploy Terraform, undeploy Terraform, deploy Ansible, and undeploy Ansible. Let's see this. Here, we only have three folders, right? Ansible, automation, and Terraform. Let's see what is Terraform. It only contains our Terraform files, right? HCL language. So it's for creating a tenant in Cisco ACI fabric. And Ansible also only contains YAML files for creating and deleting a tenant, right? So let's check our main logic, automation folder. In here, let's check our HTML page first. It's really simple. We only have four buttons, right? So whole page contains only a few codes, right? As you can see here, we only have four buttons, deploy Terraform, undeploy Terraform, deploy Ansible, and undeploy Ansible. And these values are important because we are calling Python functions with these values. Let's check our main logic for it. This main logic is automation.py. And when I click it, as you can see, we are running Flask here. And it's rendering index.html, which we were looking previously, right? This four button page. And on the bottom, we are assigning a custom port. So if I access this URL with this custom port, I can see my GUI, right? Flask GUI. And let's see the logic, main logic. And it's really simple. If I click a button and click button is deploy Terraform, then it will call Terraform under bar deploy function. What is this function? This function is Terraform under bar deploy.py Python file. And it's really simple. I'm just using Python under bar Terraform library. And it's just calling Terraform apply within Python. And it's calling Terraform apply for this Terraform folder. So it will create a tenant or destroy a tenant, right? Let's see another one. Let's see for Ansible. Again, if a button is clicked and click button is deploy Ansible, it will call Ansible under bar deploy, which is this Ansible under bar deploy Python file. And it's using Ansible under bar runner library. And it's executing this create under bar tenant that we saw earlier in the Ansible folder, right? It's really simple. And you can also add a protective logic. For example, our end users may not understand, right? They can click a button twice or maybe they deploy a tenant with Terraform and try to deploy it with Ansible also. You can add those kinds of protective logic, which is a checker.py file. Let's see this source code in action. Here at the background, you are seeing a Cisco ACI APIC GUI. And we only have three tenants, right? Common, infrared management. Let's create another tenant with it. And let's try to execute our script first. As I mentioned previously, we will execute this automation.py. And when I execute it, it will give me a URL containing my custom port, right? If I access this URL, I can access my Flask GUI. And when I access it, as you can see here, we only have four buttons, deploy Terraform, undeploy Terraform, deploy Ansible, and undeploy Ansible. So let's click this deploy Terraform. When I click this deploy Terraform at the background, it's executing Terraform apply, right? Calculating resources and sending these API calls to the Cisco ACI. And when we check the APIC GUI, as you can see here, we created a tenant, right? And at the background, it's creating application profile, EPGs, bridge domains, and VRF for this tenant, right? Calculating and sending these requests to the Cisco ACI itself. And as you can see here, 42 resources I created. Let's try this protective logic. Let's click this deploy Terraform again. It checked and said us that it's already deployed. But when we check the CLI, this post request was sent to Flask, but our protective logic prevented Terraform apply execution. Let's delete this Terraform under our tenant. Let's click undeploy Terraform. When I click undeploy Terraform, it will execute Terraform destroy. At the background, and 42 resources are deleted. Let's check APIC GUI. As you can see here, fourth tenant is deleted. We only have three tenants. Let's exit this one. You can exit with Ctrl C and let's execute another repetitive task scenario. And I gave this one another custom port, so we will access it via another URL. And also you can execute your Python calls at the background using Nohub, right? And if you want to check the process ID of your script, you can execute PS command by gripping it, you know, your script name. It's simple stuff. And you can see your, you know, scripts or process parent PID. Let's access another URL. As you can see here, this is a repetitive test scenario and users can get interface speed, configure interface speed either 1 gigabit or 100 megabit or do, you know, their repetitive test scenario, right? This is simple stuff. So when I click 100 M, it changes the interface speed to 100 megabit. When I click 1 gigabit, it changes to 1 gigabit. And when I click what is current speed button, it just gives me the interface speed, right? So I'm just using get or post API calls so you can do whatever you want with these ones. It's really simple. And if you want to, you know, exit or delete this process, you can just apply a kill command and give them the parent PID of the script itself. And lastly, you can reach a repository of these both scripts from this GitHub page and you can contact me with this Twitter account handle, right? And before finishing, if you can fill out the service, it will be really helpful for us for hearing your feedback. And with this, we are at the end of the session. Thanks a lot for your attention. Thank you.