 All right. Good morning, everyone. First question, can you see the screen? Can you hear my voice okay? Perfect. Okay. So, we only have 20 minutes, so let's dive right in. Today I'm going to talk about an application that translates Ansible to Terraform using an application called Translator for ACI. This is food for thought. Ansible and Terraform are two sides of the same coin for ACI. Let's think of it this way. If the coin represents the concept of managing or provisioning an infrastructure in ACI, you have one side of the coin representing Ansible, which is more procedural or imperative in its approach, where you mention tasks one after the other in the playbook, and you tell the system how to reach the desired end state. The other side of the coin, you have Terraform, which is declarative in its approach. By declarative, I mean you just mentioned the desired end state, and Terraform by itself decides how to get there. While both of them achieve the same goal, sorry, you have a question? No? Okay. You can either use Ansible or Terraform or a combination of both, depending on the context. So what is this application? The application converts an Ansible playbook into its respective resource file and state file in Terraform. As simple as that. Okay. Few things to remember. This is only designed for ACI. The application that is. It's only designed for ACI. It's not a direct language conversion where Ansible playbook is written in YAML format. The YAML format is not converted into HCL, which is Hashi configuration language, which is written in Terraform again. So it's not a static translation. You need Ansible in the backend, which runs the playbook you want to translate, pushes the config to the APEC and Terraform imports that config. So minimum requirement would be an APEC simulator or any APEC will do really. Okay. The million dollar question. Why move from Ansible to Terraform? If you're using Ansible to configure an ACI infrastructure and it becomes large and it's growing, the real challenge is keeping track of the real world resources in ACI. This can be overcome if you use Terraform. So in a way you can translate the Ansible playbook to the Terraform config file and the state file, which serves as the source of truth of your ACI environment. What do I mean by a state file? It's nothing but a snapshot of your infrastructure at a given time stored in a file. This helps Terraform identify if there's any change in the desired config so that it can match with the ACI infrastructure. The second point I would like to talk about is if you're using Ansible to manage your on-prem infrastructure, which is part of a hybrid cloud environment, Terraform being cloud agnostic is the likely contender that's managing other cloud infrastructures. It would be helpful if you converted your Ansible playbook into Terraform config so that you're using one tool for the entire hybrid cloud environment. And why use the translator? A user simply wants to migrate from Ansible to Terraform and he doesn't know where to begin. This app is a good starting point. Let me pull up my application. Let me show you the playbook called My ACI Playbook, which is in the demo one folder. Can you see it? So, this playbook essentially sets up an L3 out. It configures L3 out so that there are configures network routing so that there's outbound connectivity from your ACI fabric to your external networks. That's the gist of this playbook. Choose file. And let me enter the credentials. And let me hit the translate button. Now while it's translating, let me explain what the dry run option is. Now if you want to translate a playbook that has already pushed its config onto ACI or an APEC, and you don't want to push it again to the APEC, it may cause uninterrupted changes so you never know. So you select the dry run, the playbook runs in check mode in Ansible. And it's still translating. So let me explain the structure of the application. So the application is running in a front-end Docker container in conjunction with a back-end Docker container. So right now what's happening is the playbook is being consumed by the app. And then it's modified by the back-end. And once the playbook is modified, it's run by Ansible first. And then the Ansible to Terraform playbook is run next. So now the translation process, it communicates with the APEC, the back-end that is. I'll come back to this. Okay, so it's complete. Let me download the translated files here. And let me go to the downloads folder. Unzip the downloaded file. And let me open the three files that are important to us right now. I hope you can see this. So the three files that we have that were translated from the playbook was the provider, the resources, and the Terraform state file. The provider, Terraform provider, it's analogous to your Ansible inventory, where you have the credentials of the APEC and the provider plugin information, which is analogous to your Ansible ACI collection. So in a similar way, you have a provider ACI. This is the Terraform config file that's been translated. Let me just put this on the right. So for each task in the playbook, you have a corresponding resource in the Terraform config file. Okay. So this is analogous to your playbook in Ansible. Next comes the all-important state file, which is unique to Terraform. Now the state file, as I mentioned before, is a snapshot of your infrastructure. This infrastructure currently exists on the APEC. Now the state file consists of a resource ID, the resource attributes, the resource name, the resource type, and dependencies. All the attributes that I just mentioned now are important information for the Terraform to map to the real-world objects in ACI. Let me pull up my terminal. And let me show you a few Terraform commands before I continue with the slides. Okay. Okay. Serious place. Oops. Okay. The first command is terraform init. What this does is it initializes a working directory that contains your configuration file. It also downloads and installs the provider plugin, which in our case is ACI. And let me show you the next command, which is terraform plan. This command creates an execution plan in Terraform. And it says no changes. Your infrastructure matches the configuration. This is because Terraform compared what's there in the resources config file with the Terraform state. And it figured out that there's nothing different. So it's not going to push anything. Now let me... So I have this tenant called ansible2tf. Let me make a small change. I'll change the annotation to terraform. So now I have changed my desired config. One single attribute, not a big change. So let me again do terraform plan. So now terraform identified that there's a change in the configuration. And it's showing us the change. Let me apply that change. And as you can see, you have the ansible annotation here. The network is kind of slow. Let me confirm. And this changed to terraform. And this is your current infrastructure in ACI. And if you look at the state file, it has a record that it's terraform, not ansible anymore. So your desired config matches with the state, which in turn matches with your current existing infrastructure. Slides. A little more detail about how the translation worked behind the scenes. Terraform manages resources using unique IDs. These unique IDs can also be used for existing, to import pre-existing resources that is in your ACI infrastructure. Now we all know that DNs, or distinguished names, are unique identifiers of objects in ACI. In terraform provider ACI, the object, the distinguished name, is nothing but the resource ID in terraform. Why does that matter? Our ansible ACI is designed to display the DN of each object a particular task is manipulating. Now, once you collect all the DNs from ansible output, you feed it into terraform import function, which recognizes those DNs as terraform IDs, resource IDs, and it outputs a config file with the state file. Let me, let us follow the same experiment without using the application, without using the web application that I just showed you. Now if you notice, I have my playbook, the ansible to terraform playbook and a custom I have the same files that I showed in the slide with an inventory of course. Let me open this playbook. Can you see the playbook? So now I made a few changes to the playbook. What I've done is I've used the register keyword with the unique identifier for each task. All of them have different unique identifiers. And I've included the ansible to terraform playbook as the last task of the playbook I want to convert. Now let me pull up another terminal and run this. So let me run my ansible playbook command. And let's see what happens. So create a tenant task. You have a DN specified in the output of ansible. This output is saved in the register keyword, the unique identifier of the register keyword. Now this has a DN as well which is add unknown. This has a DN, create static route. Now the ansible to terraform playbook runs after the main playbook has been executed. And the custom filter plug-in, what it does is it parses all the outputs of the ansible task, collects each DN from each task, puts it together, and it feeds it into the terraform import function. And the import function gives you the config file and the state file. So this is part of ansible to terraform playbook which is running. Now you've seen a few files that have been populated in the demo2 directory. Our main concern is this particular folder which is my ACI playbook which matches with the name of the playbook. Let me open that. Now this has the same downloaded, same files which I downloaded from the application earlier. So this is manual translation. So in a gist, these two are the main elements that you require in the translation process. This playbook, you register all the tasks, include this playbook to be run after all the tasks have been run, and the custom filter plug-in gathers the DNs and gives you the terraform files. Let me show you something else. Let me go to the directory which has those files. Let me use our terraform init command to initialize the working directory. It's already initialized. Terraform plan. Again it's going to show that the infrastructure matches the desired config. I'll show a new command, terraform destroy. And you have your plan that shows, okay, these are the resources, all the resources are going to be destroyed. It just tears down the entire infrastructure. And resources seven destroyed. It's gone. Now this was a single playbook. What if you have dependencies? By dependencies I mean I have a playbook that is dependent on a CSV file. It also uses a separate filter plug-in for manipulation of variables. This can be translated using the manual translation just by adding these two files here in the CSV folder. But I'm not going to do that. I want to use the application to translate the web application that is. So let me go ahead and compress this into a zip file. Let me refresh this. Choose files. And you can see the back end Docker container running here as well, which is the same translation process that's taking place. So the app is designed in a way where you can also translate an entire Ansible role. If you know what an Ansible role is, then you just have to zip the Ansible role, upload it or select the zip file from the application and it gives you the respective terraform config file. It also gives you a log file if you need to, if the application encounters certain errors. It will display a message saying, okay, it came across a few exceptions. So once you download the file, you will have a log file. I can show it to you once this translation is done. So execute it successfully with exceptions. Close, download. Let me open that. And you have a log file where all the warning and the error messages are displayed at the bottom. So I would like to end the presentation with one takeaway sentence. On a conceptual or a functional basis or view, what Ansible does to a single task in its playbook, terraform does to its entire config file. Thank you.