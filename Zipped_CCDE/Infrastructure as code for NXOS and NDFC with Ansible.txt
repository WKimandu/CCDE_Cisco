 Infrastructure of code is actually a rather simple principle. It's very straightforward in reality. It can be hard to implement at scale. We're going to walk you through how you do that in this session. But first, let us define what infrastructure code is. It's taking the reusable task that we all perform. With what we do at Cisco, we do it too. I build test labs for customers. That's a highly repeatable task. You all have your own highly repeatable task. And taking that and modeling it as code in some form or fashion. Now to do that, we start bringing in software aspects and principles and tools into our industry, into our world. Some of those are version control, so that's Git repositories or repositories in general. That's pipelines. Has anybody started hearing the word pipeline in our industry quite frequently? Yeah, it's become quite the popular buzzword. We'll define what that CICD means here in a second. And when we start doing all this in an automated fashion, it is really good practice, highly recommended. I have a test background. It's what I do for Cisco. I do lots of testing. It's to also include test automation, not only for your code, but also for the code that you are using to automatically take care of your infrastructure. Now we put this together just as a reference. A lot of people sometimes hear these words. These acronyms and terms, and they don't know how they all tie together or where they fit in the picture. So an SCM, that's your software code manager or management. How many of you have heard of GitHub? Okay, whole room. How many of you have heard of GitLab? Just about the same. All right, good deal. You'll actually see GitLab toward the end of our session, but these are where you create those repositories and have those version control systems. Now for when it comes to a pipeline, Jenkins is by far probably the most popular coming from the software dev world. You'll see GitLab CI in our session because we're using GitLab, so why not? GitHub Actions is rather new, but GitHub has its own more or less pipeline nowadays. And the last thing we wanted to define for you is a list of infrastructure code software tools or automation execution tools. It's a given we're talking about Ansible here in this session, but there are a number depending on the type of infrastructure you're working with. So when it comes to infrastructure as code for network, it's a given. When it comes to network operations, it really doesn't matter the tool. It doesn't matter the programming language. Again, the principle is taking your infrastructure and mapping it into code in some form or fashion. So that code becomes the source of truth, not your networking device itself. Now I wanted to give you a 10,000 foot view of what this looks like when you pull it all together. You have your little man over here, your little person over here doing their infrastructure code. That's me. We're hacking away. We are coding away. We want to commit that to one of these SCM platforms. In our case, GitLab again for our lab. So when you commit that to one of these platforms, how you build out a CSCD pipeline is that platform detects there's a change. Simple enough. When it detects there's a change, it fires off these things called runners. Those runners are going to go and deploy your infrastructure as code to a staging environment. Now it's ideal to have a staging environment. And that can cost you a lot of money. It can come in many forms and fashions. It can be virtualized. It can be a subset of your production environment. In some cases, I've worked with a couple customers where it is the pre-staging of their production environment before it goes into production. Anything to have a staging environment to test your infrastructure code against so that you're happy with the changes it's going to make. Now that's the continuous integration portion of the pipeline, the CI portion. Now the CD portion can be defined one of two ways. When you let the CD go to the pipeline, you're going to have a continuous integration portion. When you let the CI portion run, as long as that's successful, it can sit there and wait for you as the engineer. So that's manual human intervention to say, okay, it's good. Let it provision and configure my production environment. So there's one step you have to take to say it's okay to let it go do that. That's continuous delivery. When it becomes continuous deployment is when you and your workflow and the engineering team fully trust the automation. And the pipeline. That it automatically will just provision your production environment. So again, there's a difference in continuous delivery and continuous deployment. Now we're going to jump straight into infrastructure as code with NXOS. So it's an automation orchestration platform. It is open sourced by Red Hat. The best thing about it in our industry is it doesn't require hardly any programming knowledge. If you do have programming knowledge, it's only going to help and amplify things that you can do with Ansible. But it's not required. At least not from our experience. Now what is required is you taking your configuration intent, how you want your network to look, and defining that in data structures. They can look several different ways, and we'll see a couple of those here in this session and how we build that out. With Ansible defined, we need to think about what makes up our Ansible environment. Now go back to my daughter. She's hacking away on her toy laptop. Ansible is a very complex environment. People would call that your control host. If you read Ansible docs, you'll find the words control host there. This for you and me is probably a Mac or a Linux machine, and if you have Windows, God bless you. Now's a good time to invest in one of the other two. But in all seriousness, you have WSL on Windows. You can make use of that so you're not left alone. Or you can partner with Red Hat. They have Red Hat automation platform, or their open source-ish version of that is AWX. Now, I'm going to talk about the AWS. Now, with our control host, we need to get Ansible on it. Until we put Ansible on it, it's just still our laptop, per se, or a VM in a data center. Now how many of you have experience with Python? All right, good. Good number of hands. You don't really need it here. We just need a Python environment. We're going to have one comment about a Python environment after this, but you just need somewhere where you have Python and you can install Ansible, and we're going to go through how you install Ansible because there's a couple ways that's changed. I just want to make sure it's fresh and current in your mind. Now with Ansible installed, how Ansible is structured nowadays uses collections. We're going to focus on mainly three collections in this session. The built-in collections, the NXOS collections, that's probably a given. And then, wait, does that say DCNM? All right, well, I'll let Mike demystify that. I don't even know what that means. So I'm going to let Mike clarify that for you. We got DCNM here. He's going to talk about NDFC. He'll marry that together for you. Yeah. Appreciate it. Just want to, don't want to steal your thunder. So once we have our control platform and Ansible installed, we are now ready to start modeling our infrastructure as code. Again, this is our intent. This is where we want to create our source of truth that represents our network. Ansible is going to do that in something called Playbooks. Now we're going to break all of that down there and how you pull that together in a use case. Before we move on, though, we need to tell Ansible who our targets are, who we're going to connect to. As I talk to you about NXOS, keep in mind that's direct to switch. So every switch you have in your network or every switch you have in a fabric, that control Ansible control host is connecting direct to switch or switches. When Mike talks to you, it's going to be direct to controller within DFC, right? There's some subtle differences. Now I do want to point out with NXOS when you go direct to a device such as a router or a switch. Ansible does support three ways of doing that. Obviously, the CLI, good old SSH. They call that the network CLI. We do have netconf here, but we're not going to cover that in this session. If you want to talk about that afterwards, please find me. There's some subtle differences with how Ansible automation works. It's kind of outside the NXOS things we're going to cover here, but it absolutely works. Now with NXOS and the REST API, if you are using NX API, everything we talk about with the NXOS, excuse me, then say something five times fast. The network CLI. We'll actually work with NX API via the REST API plugin inside of Ansible. Now I told you I wanted to do a quick word about Python. Again, you don't need to know a lot about Python. One thing I would highly encourage you to do though is establish a Python virtual environment in some form or fashion. You can do this natively with Python 3. We have a reference slide in your deck with how I like to do it. It's pyenv because it not only lets you create the virtual environment, it lets you instantiate different versions of Python itself. So, you may have use cases. I saw a lot of hands that came up about Python. You might have some things you're trying to do with Ansible. You might need different versions of Ansible. You might be developing some little command line application or something in your Python. It's best to keep those separate. So we have a reference slide there for you outside of scope of the session, but we don't want you walking out of here thinking, you know, I got my laptop and I can just slap Ansible on it. Take this step first. Highly encouraged. Now, I said there's a couple of ways to install Ansible. I said there's a couple of ways to install Ansible. This changed over the last couple of years. So how you install Ansible is using the Python package manager pip. So you pip install Ansible. If we pip install core, that is going to come in a that is going to give you Ansible in a lightweight fashion. It's just going to give you the core components. So remember that built in collection that I showed you at the top? So that's something that comes with the core components. Anything else you need, you actually have to install yourself. Okay. So the benefit of that is you potentially when you go install the collections, you're going to get the latest and greatest. That sound good? Now if you do the traditional manner of installing Ansible where you just pip install Ansible, you'll find this in Ansible docs. I think we laugh and joke about it, but it's the batteries included. It's the whole thing still. Okay. What that means is Ansible core along with a curated list of collections that Ansible prepackages with the install. And XOS is one of those. But it doesn't mean you're getting the latest version of the install. It means you're getting the latest version of the collection. So keep that in mind, right? Subtle little details. Now with defining what Ansible is and bringing up this term collections, want to double click into collections just briefly. Make sure we're all on the same page. So collections has been in existence since really Ansible 2.9. It was kind of in a beta pre-release stage in there. You could reference the old modules and the new way the modules are referenced. If pip is in the old modules, you'll be able to see that the new modules are not in the old modules. So as I mentioned, if you did Ansible core and you need to install your collections, you're going to use this command here at the bottom of the screen. You can see that I do Ansible Galaxy collection install Cisco NXOS and Cisco.dcnm. Okay. And that will give me those collections in my Ansible environment or my Ansible collection. Now, the important thing about collections is really that it's going to give you a bunch of modules. It's a bunch of code that's already been written to do something on our switches and routers on our behalf. Okay. Code that you don't have to go and write. And a lot of that code is going to come with filters and plug-ins for things. We'll hit on a couple of them in this session to optimize things you're doing in Ansible for delivering your configuration to the switch. So taking the NXOS collection. As an example, there are 77 modules. Test one, test two. Am I back? All right. Can I get a round of applause? No, I'm just kidding. All right. So as we were going, we're going to take the Cisco NXOS collection as our example and double click into that so we can see kind of what's packaged there with those modules. Again, as I was saying, there are 77 modules already there. They do a whole lot of things. There's a whole lot for you. Interface configuration, VLAN configuration, a whole bunch of routing protocols, et cetera. Now I don't say this lightly. I'm actually impressed with the documentation with these modules. It tells you how to use them all. I'm going to learn by doing and seeing. There's lots of examples there to help you get started. I really like that. The module documentation also has the parameters that are required to run the automation. As well as the ones that are set by default so that you know what is set by default in case you need to override it. I want to point that out because that's very important sometimes. Sometimes we want to override the defaults that a module has set. Just keep that in mind. Now one thing I'd like to maybe demystify, I hear this from customers sometimes. They wonder who to reach out to if they have a problem when they use Ansible. Well, our NXOS modules, iOS modules, and iOSXR modules are actually maintained by Red Hat. But maintained with heavy Cisco support in the background. So just keep that in mind when you're using those core modules. Now if we take one module out of the NXOS collection, out of the 77, and we look at this NXOS VLANs module, when collections came into existence, it became best practice when you were writing your Ansible automation to use the fully qualified collection name or the FQCN. Say that one five times fast. We're used to saying FQDN. But FQDN. Throw a C in there. Now you have the collection namespace that is part of that now. So Cisco obviously here for this conversation. Then you have the collection name. And then the actual module name. And that's what most of us are familiar with with Ansible if you started with this in the early days is you just had that module name. Now as I was mentioning in the documentation, it tells you what you need to drive a module from an automation standpoint. Every module is going to have parameters. Every module is going to have parameters. And you're going to need to pass in some type of value into those parameters to drive that module's automation. Okay, great. We know what Ansible is. We know how to get it installed. We know about collections. So let's start pulling all that together with some Ansible concepts for our use case. Now for this session, I am going to describe to you and build out with you Ansible best practices for a VXLAN EVPN use case. How many are familiar with VXLAN? All right, good. Most of the room raised their hand. That's awesome. If you're not familiar with it, it's not a big deal. Everything we're going to show you here applies to traditional networking. It could be a three-tiered architecture. It doesn't matter. Okay? Just the intent that we're going to describe here is relevant to VXLAN, but you can take it and mimic it for any network architecture. Now when we start with VXLAN EVPN, just a base fabric, we have a simple one here. We have five devices. Okay? We want to do common configuration to all of our devices in the network. Again, VXLAN EVPN or not. We want to set host names. We want to install features. We're dealing with Nexus here, so we're going to install features. You could add to that list things like NTP, AAA. We want all these devices to have those things configured. We want all that intent defined and configured by our automation. Well, with VXLAN EVPN, we then need to establish the underlay. We need to figure out and define how. all of our switches are going to be connected to each other. So that's going to be interface information, interface state, IP information, and also descriptions. You're also in the underlay going to find routing protocols. So you can see there's quite a bit for underlay configuration that we'd want to define in our code. Lastly, to get a base fabric up, you then need to define the characteristics of an overlay. These are going to be VRFs, VLANs, host-facing SVIs, etc. Now, when we bring this into Ansible and start modeling it as code, we have to define a directory structure. Those of you that have used Ansible, any pains with the directory structures? Does it all make sense to you? Yeah? Okay. Ansible directory structures are very important, and what we have here is a slimmed-down version of a best practice way to define that directory structure, one you could use to start with and then scale up, or you could compare it to what you're doing today and see if you need to make any modifications. We broke this down into four categories. We need to define where to do our automation. So this goes back to our targets that we defined early on, the data to do our automation. Remember, you've got to have parameters fed into your modules to drive your automation. And then reusable code. We want to make sure we write highly reusable code. We don't want one-off tasks and playbooks, right? We want to make sure that's how we do it. And then at the very end, how Ansible pulls all this together, as I mentioned, is in playbooks. So we're going to define a playbook, and it's going to take all of the above, it's going to pull all of the above together to run our Ansible automation. Now, here, you can see our simple playbook defined, and we really want to do three things. I kind of described it going over our fabric. We want to do common and underlay configuration, and we want to do overlay configuration. Some of you, I'm not sure if you've seen playbooks designed this way. We're going to do this to show you how it's done in a reusable fashion. But you may be asking yourself, well, now, how does that playbook know what devices to connect to and where and how to apply certain pieces of configuration? Well, that's where the Ansible inventory comes into play. Now, you could have more than one inventory file. We're going to use one here for the purposes of this session. But in the inventory file, it's where we start taking the connection information using Ansible. So, we're going to start using parameters defined by Ansible that you need to populate, and they tell you how you connect to your switches. Again, here, we're going to use the network CLI, right? We're going to stick with good old SSH. But then we define our username, password, and in this case, since we're using Cisco NXOS, the network OS is Cisco NXOS NXOS. Now, the next thing we do in our inventory files is a good practice, is to start to group our devices and how they reside in our network. For a VXLAN fabric, as you can probably guess with a lot of people, it's going to be a VXLAN. So, this use case is pretty easy to do. We have two spines, so we can group our two spines into a spines group. We have three leafs, so we can group our three leafs into a leafs group. If we head back to, well, excuse me, sorry about this. There is some slide real estate we needed to salvage in this session. So, we're going to take the Ansible connection and just simplify it down into network CLI. Wanted you to have that in your notes, your reference slides that you take away from here. So, if you're looking back, you know why we changed that. In the examples. But if we do go back to our main playbook, we can now look at the three things that we wanted to do, the three configuration things we wanted to do. Again, common configuration, underlay configuration, and overlay configuration. We can look now and understand that our common and underlay configuration is going to be applied to our spine devices. Our common and underlay configuration is also going to be applied to our leaf devices. And our overlay configuration is only going to be applied. To our leaf devices. You can see how with Ansible doing it this way, we can target our configuration to specific devices based off how we have our reusable automation defined. Now you might be asking yourself. How do we define that reasonable automation? How are we telling Ansible what we want to do to our switches? And we do that with Ansible roles. Now a lot of hands went up about Ansible. How many of you are using roles? Not as many. Not as many hands. That's good. So Ansible roles is a good way to define reusable task in Ansible. So take your general playbooks and you take those tasks that you have in your general playbooks and you group them into these roles. This is very easy to do with a VXLan EVPN fabric use case because again we had our three configuration tasks that we want to do. Right? We have common configuration. We have underlay configuration and overlay configuration. You're going to get tired of me saying that, but I want to make sure you don't forget it. So we can group all of our common configuration task into a common role. We can take all of our underlay configuration tasks into an underlay role. We can take all of our overlay configuration tasks into an overlay role. That all make sense? Awesome. A lot of head nods. Now if we expand out what the directory structure and this is a simplified directory structure for this session for a role. It is the task section here where we pull all of that together to define. How we're going to configure our switches. Okay. Now I tried to find a Taylor Swift reference to this. Don't ask me why, but I tried to. How many of you can go back to 1995 and remember a hit song that uses the this is how we do it. Can anybody go back to 1995 remember that? Awesome. Now I can't I cannot sing so I'm not going to sing it for you. But there is a song that I want every one of you to pull up on your flight home. Spotify, Apple Music. This is how we do it. And you're going to rock out to that and start your infrastructure is code journey right there on that plane. Okay. I want to have some messages dropped in our WebEx space that I'm doing it. Give me a picture on your flight right there. Let's make it happen. Now you'll never forget this though. You'll never forget the this is how we do it. This is in Ansible. This is how we actually apply the configuration to our switches through these reusable roles. So if we unpack the roles just a little bit right. So we're not looking at a whole bunch of code all over the place. And definitions that way. Let's look at it kind of from a graphical point of view. I verbally talked about what our common role was going to do. It's going to handle things like our host name and features. Again you can keep expanding that if there's common things that you do across all your devices in your network. They're all going to go there. Okay. Those tasks are going to go there. The underlay very simple interface information IP address stuff descriptions routing protocols. And if you do multicast in a VXLinux VPN. You're going to get a lot of stuff. And fabric all your PIM stuff is going to go there as well. Then for the overlay. If we build that out again we need VRS. We need VLANs. We need host facing interfaces. We need that NVE interface to map all that to to make our leafs virtual tunnel endpoints or VTEPs. Right. So that that's all handled in that overlay role. Now I want to expand just the overlay role for the purposes of dialogue here. You can see this is the overlay tasks main.yaml. So this is the actual task file for our overlay role. Now it's a snippet of it. Can't can't fit a whole lot of this on a slide. So we're going to we're going to look at a snippet of it. Now we're using that same reference and XOS module we referred to earlier. Right. And XOS VLANs. Here we're taking a list of VLANs. And we're sending it in a config block to the switch. Okay. Now remember when we use this role it's actually applying to all of our switches. This data structure that you see in front of you is a simple what we call YAML list. How many are familiar with YAML? Okay. Great. Awesome. Majority of the room. This is a YAML list and it's actually a list of dictionaries. There's a bunch of key pair values there with the name the VLAN ID and the map VNI are all the keys and the values associated there. So now this is the data or this is how we want the switch to be configured with these items. So let's pull everything we've done. Up to this point together. That sound good. So we can see how it all connects and plays well together. We have the way we want to do it defined in our Ansible inventory file. Okay. These are targets. One or more switches. We have five in this case. We pull together and we pull out our main playbook. This is what we want to do. Okay. Remember we want to do common configuration underlay configuration and overlay configuration. We're going to stick with the overlay configuration example because that's the role we were looking at. So if we pull that task file out and look at that we have that same overlay role sitting here now side by side. So now you can see all the three pieces that we've looked at up to this point. Now again just to drive the point home our leafs are going to reference our leafs in our main playbook are referencing our leafs to find an inventory file and the overlay configuration we have is referencing that task there. And again when this does that 3VLANs to all three of our. Leaf switches. I think that's pretty awesome. I think that's pretty easy and pretty straightforward. Does anybody agree. Can I get a show of hands. We all agree that that's pretty easy that's pretty straightforward. Okay awesome. Some hands had nods. Good deal. All right. Don't don't do your variables this way. Don't please. Okay. This is just for illustrative purposes to show you how to pull all this together. But do not do your drive your data this way. Okay. It does not make your roles is reusable as they can be. So let's look at how we can make them. More reusable. By default a role is going to be named main.yaml when you first create it. But you can use any name and include it in the main.yaml. It'll only run your main file. But if you include. Something with the include built in. It'll run anything that you include below. I was trying to think how to answer that a little differently. Because one of those built in. Modules that comes with the Ansible. Core collection. So that built in collection. There's a bunch of include type modules. So you can actually include roles within roles. You can include other. Tasks from somewhere else. And that would be what you do. Here in this case. Okay. So a quick word about variables. Again. This is just a level set makes. We're all on the same page. And we know how to reference them all the same way. Now. Variables and Ansible are primarily used within the tasks of the modules that we just looked at. They can be used in conditional logic. They can also be used in templates. Another thing that we're going to show you in this session is how you can use. Excuse me how you can use variables and define them on the fly dynamically within your task. Does anybody do that today. Does anybody build dynamic variables in your playbooks today. Awesome. Pretty cool. Pretty cool. Now when we reference variables and Ansible. We do so in what's called Jinja 2 syntax. Or reference it in Jinja 2 syntax. So if we take our same NXOS VLANs example from before out of our overlay roles. We can institute variable substitution. How variable substitution looks is with quotes and double curly brackets. Simple enough. Easy enough to recognize. So now if we look at our NXOS VLANs task. In the module. We see we have three places where we have quotes in double curly brackets. So we're doing variable substitution in three locations. We have a variable now called VLAN names VLAN ID and VNI ID. We define those variables in some file within Ansible. OK. And those are simply passed into the task and that is variable substitution. OK. The variables will take on the values of those variables wherever they're defined. Now that's great. That is a great first step in. In reuse. But we can do so much better. If we go back to the understanding that we had a list defined before. In our variable file location wherever it may be. We can define a list of that same VLAN data. Does that make sense? We've just expanded it out. Now that list again. I just want to reiterate this. If anybody isn't custom to looking at YAML. That list becomes a list of dictionaries. With all of that data. OK. Now what we can do with that. With Ansible modules in any given task. Is use a loop mechanism. Now you probably see one thing two things different here with our NXOS VLANs example. We've now added a loop keyword. So this is a loop mechanism or construct that Ansible offers. And we use the networks list that we have before. But now in our quotes and double curly brackets. We now have a new word item. Item is going to tell us. Where we are in our list as we iterate over it. So in this example in the current state we are right now. We are in our second. Entry of our list. So when we perform the variable substitution this time. It's going to pull. The values from the second location of the list. I don't make sense. Seem pretty good pretty powerful. OK this is also great. But also this can be very slow and Ansible depending on your your data set. OK. So I'm going to show you one other way later on with template. How we can expedite this because every time this loop executes. It's a configuration operation. See how it can be. Pretty slow. OK when we show you how you can do it in one config transaction. Now to get back on track with our four categories. We've been looking at different ways to model the data and use the data in our task. Now we need to figure out where to define it with an Ansible. On the word about the word about variables Ansible does have a lot of locations. You can. Define variables there's north twenty twenty plus and use precedence to dictate what which ones are selected first. That's outside the scope of the session. We probably could spend thirty forty five minutes just just talking about that. There was a link that you can reference for for your own self to understand where you want to place variables. Now what Mike and I are showing you in this session is the two most common places you're going to place variables and that's in your group bars and your host bars. Group bars probably pretty straightforward if we've followed along. Up to this point remember we define two groups in our inventory file spines lease right. So if we look in our group bars we're going to have two files that model after those those groups is as simple as that. Now if we expand our lease group variable file we can see that we have things that we want provisioned and configured to every single leaf in our fabric. We want them all to have the same features. We want them. All to have the same networks same networks that we just looked at. Now when we get to host bars. This is where for some people gets just a little bit complicated because it's a little more to keep up with. Now you remember we had five devices in our fabric so you have to define all five here for anything that is specific to that device. So if we expand our leaf one as an example we have a host name to find there we have our L three interface configuration to find there. And that's going to be different across every leaf in the fabric so every device is going to have a host bars file. Now the host bars file this is where it gets a little tricky sometimes we all like to think of our host names of our devices if you didn't use your host name in your inventory file and suppose not going to find it. Okay so whatever name you used or however you use to connect to your switch whether it's the FQDN or the IP address in your inventory file that's how you need to name your host bars file. All right we're going to pull it all together one last time for the win for the grand slam. We have our category of where to do it and we know how we're going to do that with with the groups that we defined there are targets remember. We pull back in our main playbook this time we are actually going to focus on our common configuration we're going to get away from the overlay we've talked about that enough let's talk about a common configuration. So in our common for our common configuration we're going to take in it's going to be. Executed across across both the spines and the leafs. So if we pull our common configuration task in right so we looked at the overlay one now this is what the common one might look like you have a task that configures the host name you have a task that configures the features. You can see our features task is using loop it doesn't have that capability to do the the the big config block a word on that later. We have to sticking with our leaf one example because we need we need to pick one of our switches an example here. So. We're going to stick with our leaf one our leaf one has access for variables that are in the group bars leaf file and it also has its own specific host file. So for configuring the host name is going to reference the variable directly out of its host file but for the features is going to reference it directly out of its group leaf bars file. That makes sense we're pulling variables out of two different locations to make this a highly reusable task. Now. That's great we pulled all this. Together. A question I get a lot of times is after you do work like this is like I want to run it how do I run it how do I make it work. Very simple remember on your control host. My daughter sitting there hacking away she wants to run her playbook she just needs to do Ansible playbook minus I. Okay there's a lot of more command options with Ansible playbook but minus I is the thing we need to specify our inventory file that stands for inventory. Then we want to take our main playbook in our case we created that VX. Lan Yamo file is our main playbook you pass it in and you'll see something like this this is a main playbook running against the five node fabric just like we talked about using the same exact roles that we talked about. You see a lot in yellow that means Ansible is making those configuration changes this is how you see that I didn't potency that maybe you've heard with Ansible right there's a configuration change occurring right now. Now. That's Ansible concepts around NXOS with infrastructure. Is. Code but I want to point out some details specifically about NXOS when you're doing this. For starters there are actually two types of modules can get a show of hands of how many people that knew that. Not so many hands. There are the traditional legacy modules and there are these things called resource modules you're going to want to look at the resource modules in any of the work you're doing because this is how we achieve that. Single transaction for configuration and will double click into that on the next slide. Now what. Ansible and Red Hat learned over time is between network vendors are network OS is the legacy modules were not always consistent. Okay if we did OSPF module and NXOS but then iOS and then you went to some other vendor they might not all look the same. Okay. The other thing with legacy modules is they must use the loop constructor mechanism and Ansible because they can't take the bulk configuration that I'm going to show you how resource modules can take. The other thing about legacy modules they really had two states it's not super ideal for infrastructure as code but you can make it work. They had the present state and the absence day so present means creating absent means deleting. With the resource modules they became consistent across the board within the same OS between network OS is between vendors OK so they look and feel the same if you have a if you have a heterogeneous or homogeneous environment they're going to look and feel all the same. No matter. Who would vendor or network operating system you're working with. Now they can still leverage the Ansible loop construct but again there is a way you can kind of send all the configuration in one transaction to speed up your Ansible execution time. And lastly they actually introduced a number of new states for consistency and clarity. What Mike's going to talk to you about actually covers this as well so we didn't want to hit you with it twice so I'm a leave that to Mike Mike's going to cover these these states with you because they also apply to. The NDSC modules. K alluded to this a number of times where we talk about we can use templating to do things with a single transaction if we look at our task now we still have our index OSV lands but we've added something before it. Using Ansible's built in module set facts so this comes out of that built in collection we are going to do a look up with a plug in to a file that has a dot J to extension. A dot J to extension. Is a ginger template. Okay still using ginger here. Okay we're not we haven't really changed that we're still leveraging the same ginger stuff. Our simple little ginger script at the bottom is has a for loop in it that's going to iterate over our same networks that we've already defined multiple times throughout this session and building out our Ansible playbook. What happens when the ginger template runs and iterates over that data structure is going to set a variable with set facts. So. We just dynamically set a variable in line in our task. Okay we're back in our overlay task. So we just created a variable at runtime while while the things running. That variable then gets put into our index OSV lands this time we're going to use a little filter trick here there's a ton of these filters these are things you don't have to write yourself. Okay we can do it with JSON YAML etc. We are building a YAML payload that matches the expected parameters to this resource module. We know it's a resource module because it has this config parameter. I can take this entire data structure I've got to be lands here it could be fifty and I can send that all in one config transaction to my switch. Sound pretty cool. Now there's two other things I want to hit on that are specific to an exos when you're doing infrastructure as code there comes a time when you will run into a situation where. There is not a module for what you're trying to do I know that's hard to believe when I just told you there's seventy seven of them. But you will run into it and actually have an example right here when we build out that the excellent EVP and fabric in our underlay role we didn't dive into that one. Purposely so because I wanted to make sure we focused on something that came out of that role and that is where we had to use the index OS config module to actually configure our PIM any cast our peas between our spines now there are PIM modules. But not one that will set up him any cast our P for me. So we can take the CLI config that we all know and love right there were anchored back to and we can pass that in as lines of config with this index OS config module. OK so you can achieve still anything that you want to configure with this fallback module I do want to reference two other things about this module that are pretty important from my perspective with infrastructure as code is one you can take a running backup of your device before change window. I think that's pretty good cool because you can store that as in your get repository as as an archive in your version control the other thing is all these modules that brought up this be excited to be in fabric guess what they don't save anything they do all the configuration for that particular piece of the network that you're building out this is the module you need to use to actually commit and save your running config to your startup config and we can do that in four ways. Well there's really three the fourth way I'll go and jump to is never never save but that. Probably sounds like a bad idea. Now the first one is always always perform a save always write the running config to the startup config. The second one is modified and the third one is changed now these tend to kind of confuse people so let me try to demystify that. Modified is only going to actually perform a save operation a copy run start if if there is a change in the running config since the last time the startup config was saved. Okay. The changed option is only going to run if this task and it so it's config task has made a change. Now customers I've worked with sometimes this is important especially between the always a modified the frequency in which they want to perform their their right operations essentially their copy run start operations. So keep that in mind I've worked with some customers where they just save all the time at the very end of every every time a playbook or a roll runs. But that's something you'll need to determine about your. Your environment. Yeah. Never. It's never. Yeah. Do you want to take that one between the legacy. So the answer is it's not going to undo it. There. Is a trick you can do actually did a slide of the on this years ago at Barcelona where you can actually use a snapshot capability and XO S. And create a snapshot and then use basically a block within ansible and so if anything fails in there then you can basically add kind of a recovery clause to to basically go back to that snapshot. People. I'm. So it basically just creates. Kind of a snapshot of the running config before you start applying any config that anything fails in there that it basically just reverts back to that snapshot. I want to see what Mike had for you the other way is when you do in XO S. Config there's an option to do a config replace but to his point you still have to take some type of precursor backup and then you can do a config replace to revert it back. You. Do. You. Can. Yeah we're still dealing with the CLI this is CLI automation in the day right guys we're still dealing with the CLI buffer and how many commands they can take right that's that's really what you're alluding to. But that's the point with infrastructure as code is you're breaking these things down into smaller parts of the network we talked about your roles with common configuration underline overlay. But you can break the roles down to maybe something even more granular protocols I could have a role based for my routing protocols I could have a role for my layer to so on and so forth so your transactions your config transactions. Would be smaller. I'm sorry he was asking a question about if there's a problem when you run an answer will playbook does it revert itself back. Now one other kind of fallback module I want you all to be aware of is in XO S command don't see this one use quite as often as in X. In XO S config but I have I've seen uses it enough and I've I use it myself. It lets us in any arbitrary show commands so when we're running for example our infrastructure is code if we want to grab kind of the your before and after states for example this is a great way to do that. If you need to handle prompts okay there is a copy module but for example it doesn't do FTP if you actually need. FTP the index was command module has this these parameters for prompt and answer so you can pass the command you want to it. And whatever prompts that you expect back you can respond to that in line in code okay so pretty pretty useful for some corner cases. Now one last example. When we build out our VX and EVP and fabric earlier and you saw that big playbook run. I thought I was pretty cool that the entire network was just being brought up in that playbook as code right I'm never going to see a lot of touch or do anything. Now if I just want to add a new overlay. Okay I just want to add. Some new networks. This is kind of what the config looks like if you do this by hand. On the left and right side of the slides. In the middle these are the modules that you would need out of the next collection. To make this playbook run and just provision the new networks or the new overlay I literally only have to go. To my group bars leafs file remember where we moved our networks into we put our networks in there. And said the leaf was going to reference the side of there. That's the only thing we have to go touch we update that list of our new networks that we want to provision and we rerun the playbook. That's all we do. And that's what's going on here in front of you. You see the green that's the item potency showing in Ansible where. The things that were previously defined in our network list are are are already configured on the switch that again item potency piece Ansible knows it was configured. The yellow is the new networks that were provisioning into our fabric. Pretty cool. Awesome. I wish I wish I could say yes. Now. I've talked to you about an exos. And Ansible and how you apply that as infrastructure as code using a VX lane EVP and use case. And that was all direct to switch so keep that in mind. I'm going to pass over to Mike now and he's going to show you how to use in DFC and Ansible for infrastructure as code but now it's direct to controller. Thank you. So. The old name was DC and that's kind of the older monolithic application. It's a very powerful application that allows you to basically build fabrics. The new name is called NDS your Nexus dashboard fabric controller. Now the Nexus dashboard fabric controller actually it's it's an application that that is installed on Nexus dashboard and it's part of a suite of applications that allow you to manage your data set. Center. So just a couple others. I want to point out is orchestrator orchestrator allows you to manage multiple fabric types of if you have ACI based fabrics or NDSC based fabrics. You can manage that with that application insights gives you day to observability and the one that we're talking about today of course is fabric controller. Now the reason it was re architected is because it we wanted it to look and feel like our other data center applications modern topology views workflows. And it's also been re architected using a cut kubernetes microservices architecture. So it it scales better and performs better. But today we're focused on automation. So one of the cool things about NDSC is the application itself already has a lot of powerful automation built in. So Matt when he was going through direct to device you have to define the topology right. Ansible doesn't just tell you what the topology looks like you have to interconnect everything come up with the IP addressing scheme all of that with NDSC. You can basically go from provisioning of fabric in days because it's complicated provision of fabric right and you can actually do this in minutes now because what happens is when you actually bootstrap a device and NDSC. You designate a role so as an example let's say I want to bring in a spine device or two spine devices and four leaf devices. NDSC will basically all you have to do is give it a seed I seed fabric IP it'll come in you designate a role say I want this to be a spine device I want this to be a leaf device and it will automatically start to apply the best practices template based CLI configuration for that role. So it knows what a spine role looks like from a configuration perspective it know what knows what a leaf looks like from a configuration perspective you you you couple that with Ansible because it's got a very powerful northbound API. So you don't have to click in the GUI anymore you can drive all this through the northbound rest API that integrates with tools like Ansible and so that's where you start to get the enhanced programmability pieces all right before I do this though Matt referenced earlier. We made a lot of references to DCM I don't know if you noticed that but the D that the collection on Ansible Galaxy is still called DCM so you're probably wait a second I thought we were talking about NDSC so why are we referencing DCM. Well the problem is. Is that when I came up with the name for this collection all we had was DCM and I didn't have a pair of these. These are my 2020 hindsight specs infused with the latest AI that I can see into the future and come up with the correct collection name but all we had was DCM back then. But this is me wearing those and I see collection names now I could have picked the correct collection name but it's fine we went with DCM once you actually put a collection out on Ansible. But it's fine we went with DCM once you actually put a collection out on Ansible. Galaxy unfortunately it's a little bit difficult to change that name and plus if you've already written playbooks for DCM we didn't want you to have to change those modules. And plus if you've already written playbooks for DCM we didn't want you to have to change those modules. Because one of the byproducts of this is that when you actually start to use these modules so we have 12 modules in our collection you don't actually have to make any changes okay. If you have a playbook to create a verse in DCM that same playbook will work with NDSC. Now we have 12 modules you can go to Galaxy again you know Cisco dot DCM or Cisco DCM. We're not going to focus on all of these in here today we're going to focus on the subset but you can go look at the documentation to figure out what your use case demands. But these are the primary VXLAN EVPN fabric modules that we're going to focus on today. It's all built on our HTTP API plug-in so we wrote one and that's actually what distinguished us from the other modules. Here's one that can be found under technologicalaspk.com and we have some string reverbs for an example and can also be used to copy and paste somebody to the data that they've already created. So the productor enabled this is all an important place to go because if you're trying toenut that'd be anti engineering if you're self in fantasy you don't want to have to. I did remember to add that a second second maybe an Bijler that should appeal to every downloader is an amazing service for download and immediately download the package. Very undertaught they've done basically well that's just been kind of that's just the new addition you come back to and we've never used into that question which does not dropdowns through operation at fancy I can always. opinion we always need fire because we want to forge it probably don't need that in automation but I thought this was a really cool picture so let's talk about levels of complexity we all we obviously saw the case that this is a a single leaf device we have a lot of CLI configuration that we need to manage now who's actually written has anybody written their own python scripts to manage CLI configuration on their devices anybody okay so you know it's fairly difficult right it takes a lot so when we start to introduce NXOS modules and Matt was talking about the the direct to device approach I wanted to just kind of highlight how the different modules like the different aspects of the CLI that these manage because NXOS modules start to module start to treat the CLI kind of like objects so it'll actually look and say is that particular command or is that particular configuration already in the right state and if it is you can't do that so we're going to start to introduce NXOS modules and we're going to start to do that so we're going to start to introduce NXOS modules and we're going to start then we're not going to touch it and of course with Ansible you can start to you know include all of this code that you're writing in a github repository and manage your network using infrastructure as code principles but what if we had an easy button right that's where the controller comes in so it makes configuring a VXLAN EVPN fabric much easier you combine that with Ansible we only have seven modules now that we need to worry about so we're going to start to simplify things a little bit but we're very use case based now so we're talking about VXLAN EVPN so let's walk through some of the steps and talk about what we want to build today so the first step we're going to I'm going to show you kind of how we put the modules together to build this we want to create a fabric now if you've used NDFC quick show of hands who's familiar with the templates in NDFC or DCNM all right so we're going to start to build this and we're going to start to build this so the first step when we create this object we have the ability to just use the default templates values or we can actually use Ansible to override those template values so as an example let's say you wanted to change some of the underlay parameters or overlay or VPC or let's say we wanted to change some of the bootstrap capabilities and we wanted to actually allow NDFC to be used as a DHCP server for Pope because you want to add your devices to the fabric using Pope we can use that module to change the default parameters when we create the fabric the next step is we want to add devices to our fabric we want to add some spine devices we want to add some leaf devices now we need to start to define our overlay we have a green a blue subnet l2vni 7000 and we have a red subnet l2vni 4000 so we can obviously switch between these layer 2 if all the hosts are on the same subnet but we do want to define some of the underlay so we're going to We need a layer 3 VNI to enable routing between those subnets. And then finally, we want to configure some hosts. We have one on our first leaf. We have one on our second leaf. And so we're going to talk about the modules that we can use in the collection to make this happen. All right. So looking at the playbook. Now, earlier Matt was talking about kind of the structure of a playbook. And he kind of used the term, this is what we want to do. So what do we want to do in this particular playbook? You see at the top in the blue there, we've got NDSC controllers. So we kind of know kind of like where we want to do it. But what we want to do is down here under tasks. We want to add some devices to the fabric. Now, you see there that in green, there's this thing called an HTTPI connection plug-in or netcommon.http. Say that five times. I can't even say that. Anyway, it doesn't matter. This is how we connect. We connect to NDSC and authenticate. Now, in the middle there, you see kind of that password. It's kind of squiggly and kind of looks weird. It's a best practice that you encrypt your password using Ansible Vault. So if you use Ansible, you probably know that. But just a quick reminder, because a lot of our examples do show clear text passwords, but we don't do that in production. Now, in this particular case, we're going direct to controller. We're no longer going direct to device because the controller is the one that's managing the devices. So all we have to say is, playbook, manage my controller. So in this case, we're managing an NDFC controller. I also have a DCNM controller there. We're not managing that, but we could. All right. So now we want to create the fabric. First of all, we do need a task. So has anybody ever run Ansible Lint on their playbooks? Has it screamed at you if you didn't put a name on your task? Okay. So I put a name on my task. I sometimes forget. So today, I didn't forget. So we want to create this fabric. We pulled in a Jinja 2 template name. It's somewhere else. It could be fabric stage or fabric prod. And this is the variable payload. So there's a vars component to a task where you can say, I want to override these parameters in my templates, my fabric templates in MDFC, and I want to specify what the BGP autonomous system or ASN number is. And then the overlay mode, you know, if you're familiar with MDFC, kind of an old version of it would use this. It's a little bit more sophisticated. So we want to use the NXOS profiles to apply configuration that's no longer a best practice. So instead, we want to use straight CLI to configure VXLAN EVPN. So how do we actually pass that into the device? We use the DCM rest module. Now, I say up there that this is a stopgap module, but this is actually a really useful module for this particular part of the workflow. Because DCM rest, any API that's exposed within MDFC and that's not a node, it's a node that's not a node. And we'll actually put a link into our chat later that shows you where these APIs are located. You can pass any API. So that's what this path value is. So this is the API used to create a fabric. Post means we want to create something new. Put means we want to update something. And we basically JSONify that payload. We pass it in, and this fabric gets created. Now, you see that we have ignore errors. Ignore errors. I want to be clear. This particular module is not a node. This is not item potent. So if you wanted to make sure this fabric already existed before you create it, you could call the API with the DCM rest module to get a list of fabrics and make sure it's already there before you try to create the new fabric. Now, we do have a fabric module on our roadmap, so we'll handle that for you once it's available. But if you have something in your workflow that you need to do and we don't have a module for it yet, you can always fall back on DCM rest. Make sense? Yes, question. . . So great question. I mean, you could do it with Python. I'm not going to say you couldn't. But you don't get the benefit of inventory management, structuring your tasks the way you want to structure. And we also have a lot of very powerful modules already that do like 90% of what you would want to do in a VXLany VPN fabric. And so we always provide a rest module, though, for some of those workflow items that might be kind of outside the normal scope. So creating a fabric is usually kind of a one-time operation, so it wasn't the highest priority. Our higher priority was verfs, networks, interfaces, those kinds of things. . All right. So next we want to add some devices to our fabric. So we're going to use the DCM inventory module. So the DCM inventory module allows us to add two spine to four leaf devices if we wanted to. Now, in this particular case, you see I've got one device. It's using that kind of that config block. And so this is passing in a list. So I could pass all six of my devices in as a list of devices, and that would be executed as a single transaction to instantiate all those devices within my fabric. So you can see there that I've got a seed IP. Now, if you're used to DCM or NDFC, you know the same thing. A seed IP can allow you to discover other devices that are a couple hops away. The module doesn't support that. You have to explicitly list all the devices. But in this particular case, we're adding a leaf device. We don't want to preserve the config because this is a Greenfield import, so we're doing a Greenfield addition to our fabric. We also support Pope. This is a fairly new addition, but it's nice. A lot of customers want to use Pope in their workflow. So once you buy all those new Nexus 9000 devices from us and you receive them, you just put the serial numbers into your playbook. You put the switch in Pope mode. You can also use a playbook to do that, a direct-to-device playbook. And then run this module, and it'll pull in your device using Pope and add it to the fabric using the role that you specify. All right. So now we want to start to look at our overlay. So. If we want to add a VRF object, we use the DCNM VRF module. We have multiple states that we support. We also support deleted, but I wanted to talk about the states where we're adding things. That's merged, replaced, and overridden. Now, I've got an example in just a minute that will help clarify what those means because they can be confusing. But in this particular case, we want to add a list of VRFs. We only have one in our particular list today. But you can see there that I've defined a VRF object. And I've got a VRF name called CLVRF1 with a VRF ID and a VLAN ID. Now, if you're familiar with NDFC, you know that you can just get NDFC to propose a new ID because it's managing all the resources. If you omit the parameters in the module, it will pull from NDFC resource pool and automatically fill that in. So you don't have to explicitly specify the VRF ID and VLAN ID. But you can see in my attach block. I'm saying. I want to attach this VRF to all four of those leaf devices. Those are my four IPs. I want to attach and deploy the configuration. So that all happens in one transaction. By the way, this is, you know, quite a few clicks in the GUI. So it's nice to just be able to consolidate things using Ansible into one single transaction. All right. So, okay. Here we go. I wanted to explain states. And I thought, you know what? It's really boring explaining states with VRFs. So a couple months ago I was going to a friend's house. He introduced me to gourmet grilled cheese sandwiches. Raise your hand if you've ever had a gourmet grilled cheese sandwich. They're amazing. Right? So I got two pieces of bread. But I'm like, oh, my mind was blown that you could put avocado. You could put apples. I actually pulled just a pepper out of my fridge. I don't know if that would be good. But, you know, it seemed like it might be good. So what if we wanted to merge that with some other amazing ingredients like some type of meat, another piece of cheese? We end up with just an even better grilled cheese sandwich, gourmet grilled cheese sandwich when it's merged. So let's look at merge and how does that apply to a VRF on an NXOS module or an NDFC module that's managing the VRF. So in this particular case, you have a playbook. We have VRF1, it's property A, property B, and property D. I merged that with a VRF. And I have a playbook with my VRF1 on NDFC that has property C but it doesn't have property D. So what do I end up with after the merge? Fairly self-explanatory. We're all four properties. So I've got a problem. Right? So who's my source of truth? Is it Ansible? Is it NDFC? Now, I know what you might say if you're used to NDFC. If you go and start to configure something on NDFC that doesn't match up with the templates, NDFC will start screaming at you. And telling you that you've got config drift, which is great. But Ansible, these Ansible modules provide two additional states. One called replaced and one called overridden. That allow Ansible to start to act like the source of truth in these scenarios. So how do you replace a sandwich? So my son doesn't like gourmet grilled cheese sandwiches. He likes really plain sandwiches. I like gourmet grilled cheese sandwiches. So his desired state is the plain one. But the actual state is the gourmet grilled cheese sandwich. So what happens in a replace case? Well, we throw away all the amazing ingredients. We keep a couple amazing ingredients. But we end up with a very plain sandwich in the end. A completely replaced state. So what does this look like with a VRF? With a VRF, we have a playbook here. And this is actually now the source of truth for that one VRF. For VRF 1. NDFC has that additional property. So after the replace operation, what happens? Well, now it looks exactly like my playbook. Now, one very important note here with replaced. It didn't impact my other VRFs at all. It didn't touch those VRFs. It only touched the one that was defined in my playbook. So let's look at overridden. How do we override a sandwich? So I'm happy. My son is happy. If we get our desired state, right? But the actual state is the same. My son is more happy because he has more plain sandwiches than my single gourmet grilled cheese sandwich. So if I go through an override option, now my overridden state looks like my desired state. But what happened? We did a replace plus purge, right? We got rid of one of those sandwiches. So what happens in our NDFC module for VRF? Well, now we have two VRFs defined in our playbook. VRF 1 and VRF 3. This is my source of truth. NDFC has VRF 1, VRF 2, and VRF 3. So we don't have VRF 2 on NDFC. So after the override operation, we purge VRF 2. We also update a property in VRF 3. So you can see there that through the overridden state, Ansible is truly the source of truth because it purged anything that wasn't defined in the playbook. This can be dangerous. So I would just say use it. You know. If this is something that you want to use, it's great. It actually can be very useful in a source of truth case. But just know that these states are available for your use. There is a merge option. Yeah, that was the first one that I talked about back here. That's okay. Anyway, it's in the slide. But yeah, that's the first one where it will just merge everything. But then you've got the issue, of course, that like who's the actual source of truth in that case. Yes, question. So the module will delete it if you choose O. It will delete it. So NDFC, so the module will actually go and unattach it. Yes. But it does it in one transaction for you. So you have one task to do all of that. So it's multiple clicks in the GUI. It's one task in Ansible. . So very, very good question. It is asynchronous, right? So it will actually send it. So when you watch in the GUI, so when we get a 200 okay back from the API, NDFC sometimes is still working in the background. So that's kind of a more advanced case. So when we're adding verps and networks with NDFC, we actually have logic in our module to make sure that something is complete before it moves to the next step. Exactly. Yeah, we do pull in the module. We do provide some options in the module as well because in some cases you may not want to pull. And so we want to speed up the transaction. So you would get a 200 okay back and then you would have to use a different task in Ansible to pull on your own. . . . . . . . . . . . . . . . So let's actually talk about that offline because we are querying state before we go in to maintain idempotence. So I'd like to look at your specific use case and see if there's a particular issue that you're seeing there. So okay excellent. All right. . So we want to create, we want to finish out our overlay configuration. So the next step is we want to create our red VLAN and our blue VLAN here. So we use the DCM network module. Supports the same states that I was just talking about. We also pass in the configuration block. So this is two different list items, one for the red VLAN and one for the blue VLAN. You can see there I've got VLAN 55 mapped to VNI ID 4000. On the blue, I've got 88, VLAN 88 mapped to VNI 7000. And I want to attach red to leaf one and leaf three. I want to attach the blue to leaf two and leaf four. All right. Finally, my workflow, I need to configure some host interfaces. And so this is where I'm able to basically take one of my hosts on leaf four. This is the DCM interface module. And by the way, this interface module supports Fex interfaces, Ethernet interfaces, loopback interfaces, all the different interface types that NDFC supports. This module supports those. In this particular case, we're just configuring an access interface for that host, putting it into access VLAN 55. All right. So let's move on to wrap it, kind of bring it all together. So Matt talked a lot about reusability. I kind of broke the cardinal rule that he told me not to. And I just used straight tasks because I was talking about the modules. But in reality, you would want to take those module tasks and put them into reusable roles. So in this case, I would want to put my create fabric things tasks into my create fabric role. My add inventory stuff, I would want to put my add inventory role overlay into overlay, and then manage my interfaces all in a common role as well. And one thing we haven't shown you is you can pass variables into roles. So you can do some variability there and drive behavior roles. But that was kind of beyond the scope of what we wanted to cover. We wanted to have that literal and stock remember issues. If you have to put author code into different fields that shouldn't