 Okay, I will go ahead and get started. Appreciate you all for showing up. I know that this is probably the last session separating you and something down at the General Assembly, so I appreciate the audience. A couple of housekeeping items. The headphones are there to hear if you haven't been here before. There is a volume control on one side. It depends on which side it is so you can raise or lower my voice. I don't know if they are sound canceling, but you can turn all the way down and get a great nap if you are interested. The other thing is that when you touch them, there is also a side that changes the color of the outside band of the headphone. Make sure they are on that white looking bluey color. If they are different colors, you will pick up different channels and it may be a better presentation but you won't hear me. So with that, we will go ahead and get started. My name is Quinn Snyder. I am a technical advocate with Cisco Learning Certifications. But prior to moving over to Cisco L&C, if you can't tell by the back of my laptop, I was a developer in DevNet for three years and I really have a fascination and love for all things infrastructure as code, including Terraform. So I have done some introductory discussions around Terraform, really how to use it and how to get started, but I wanted to take that up to the next level and cover some more advanced or esoteric things within Terraform. So I have got to put this presentation together. It is my first run of it, so hopefully it hits the complexity level. But if not, I appreciate you attending anyway. So we will have, there is a DevNet, there is a WebEx room that is available for this session. My slides aren't super dense, but I will post a PDF in there as well as on the GitHub repository because most of this I hope to be a hands-on demo and show you some of the things around Terraform and how we can improve the experience as well as how we create things like modules, et cetera. So I will have a QR code with my GitHub repository and I will drop that link as well in the WebEx room probably later tonight after I have had a chance to get some more coffee. So on the agenda today, it is going to be a lot of Terraform commands. So I want to talk, the first three things on that list are really creature comforts and items around how do we make Terraform a little bit easier to consume. So I will talk a little bit about TFN, which are those who have used Python and PyN or something like ASDF or MyZonGuard. It kind of provides the same feature functionality there. I will talk about Terraform format or FMT, how we make our HCL a little bit more readable if we don't worry about that at the front end. I will talk about Terraform graph and how we can use that to get some output from our Terraform plans to show what is going to happen under the covers when we run a Terraform apply. And then the next two things are really focused on the usage of Terraform itself. The Terraform console. And my focus of that is really on how we get variable manipulation to occur properly inside of Terraform. I know there is a lot of struggle with we have these data structures where they are written in YAML or JSON or others. That we have this structure that has been predefined. Maybe we are using something like Netbox as a source of truth. We need to export those things and manipulate them to get the right output format for our variables before we put that into Terraform. We can use Terraform console to manipulate those things. I want to show you some of the tricks and tips and some of the things that I do with Terraform console before I build my plans to make sure I am doing things the right way. And then finally I will wrap it up with Terraform modules. So how we create a higher level automation or abstraction I should say across Terraform so we are not entering the same variables over and over again for the same repetitive work. So we will go ahead and get started. So first of all, before I get started, how many folks have used Terraform at all? How many feel that you are fairly proficient with Terraform at least building the HCL, being able to read the documentation, someone asks you to build something new in the cloud and you are like okay let me look at the docs and build the HCL. Yeah, okay, perfect. So we are level set about the right audience here. So one of the things that I do when I build, when I have worked with any infrastructure's code, I know Ansible has its own baggage. So I have used PyEN for a lot of my work. Terraform has made that much easier because I have said before it is a precompiled go binary. So we just download that binary and install it to path and we are off the races. The problem is that if we want to run different versions of Terraform or use different versions of Terraform, say we are looking at our dev test environment where we are going to use the new version in this case it is 196 is the latest release but maybe we are stuck on 17. Do we have compatibility with our HCL and how do we test and verify that? You are kind of left up to your own for semantic versioning because every binary is named Terraform so it is incumbent upon you to say this is Terraform 176 or whatever or however you are going to notify that. So there needs to be, it is not a need, it is a nice to have but I like to do it. There is no really good way to manage Terraform versions on your own. And so that is where Terraform TFN comes in handy. So this is a CLI tool that you can install under your work station, Mac, Linux, it doesn't natively support Windows I don't think but it does support WSL and it is a CLI tool that manages the installed version of Terraform into your path. So how many of you have used pie ENV before? Okay, same kind of principle. I do TFN if I can list remote or list it local install and I can switch those versions in between either manually by using a TFN views or if I have a .terraform version file installed inside of my local directory it will automatically switch the versioning based on what I have there. So very easy to install and it supports all versions of Terraform so not just the major versions that are in this slide here so if we go to terraform.io these are the ones that we can download and install directly from terraform.io. This will, excuse me, TFN will allow you to install all of those so let me just show you that real quick. So right now I have 198, 185, 175 and 145 installed on my system. However, we can do a TFN list remote and we can see that there's a, we can install whatever version of Terraform that we want there so we can do all kinds of crazy regression testing using TFN and this includes alpha versions, beta versions. They do a really good job of making sure that it's accessible for everything. However, if we want to go and what I'll do here, so if I do terraform version, like I said we're using 198 locally in this main DevNet 2565 folder. I'm going to move into this 02 graph folder and because we have this terraform version which is simply just the version number, 185, we can see that before I had that installed on my system, it's actually easier if I just do it here. We can see now but if I do TFN list we can see that because I have that terraform version file it's automatically set by that terraform version. So now I have a way that I can very easily manage semantic versioning of terraform on my system in a per directory or per project level. So again, kind of a creature comfort, it's not a necessity but as we start going especially with the rapid change within the providers themselves, things like AWS and the GCP providers, sometimes there's a linkage of the newer features being supported because of the way that the graphs are changing under the hood of terraform itself. Okay, making your terraform files readable. So one of the things that I've talked about kind of ad nauseam with terraform, especially when people ask me is it terraform or ansible which do you prefer, I say that there's both but they have their pros and cons. I always say that terraform is that end state declarative nature, right? We build the entire set of instructions of what we want that end state to look like and because we're using the native go, I mean HCL is not go but it has looks and feels like go, there's a very strong and well-typed syntax and structure. So we use those curly braces to denote ends of our arguments and blocks and we don't need to worry about all that weird white spacey type stuff. However, there is a way that terraform can be very prescriptive in how you format or make these things readable so you're not worried about matching up these curly brackets. It'll structure it out for you in a way kind of similar to like what Python Black will do if you run that inside of your code. It does all that linting and formatting for you. Well terraform took that and built it in automatically so you can use terraform format to do all that heavy lifting. So all that formatting that you would normally do or try to do all that white space, you can just throw it to terraform format, doesn't matter how it's written, it will structure it in the way that makes it easier to read. And on the plus side, just like everything else terraform, it only impacts .tf files. So if you have other text files or other back files or whatever, it's only going to change the format of those even to the point where in my demo I have this terraform format .backup or main.tf.back or something like that and it's formatted and it is HCL but because it doesn't have the right extension it will not be impacted. And so this is kind of a similar way of what happens kind of from my demo and I'll show that actually in real time as well. I just have a simple fabric inventory from something from NDFC, so I'm building a list, sorry a map of maps basically for devices that would be in a VXLan fabric. So I have my spines, I have my leafs, I define IP addresses, I define roles, but I've left them all left justified and I've just said I want to get what I want my inventory to look like. Yes you can read it and syntax highlighting is great as based on carbon.now.sh but there's ways that we can make it a little bit easier and in fact if we notice it's a subtle difference, but in terraform when we define maps we can say maps of a certain type. We can do map, we can do map string, we can do map all that provides an input validation for what goes into our map. In this case it actually took my map and said I don't know even though these are all strings I can't discern that they're all going to be strings in perpetuity, so let's have a map any. So any type of input that I put in there whether it's a boolean, whether it's a number, or a string will be supported properly inside of that map argument. And that's just by running terraform FMT. So what I will do here just to prove here's something similar that I had before. I have variables, users, and I have that same kind of map for fabric inventory, but you can see it's all just left justified and completely strung out. And I have this main.tf.source and I'm going to copy this and paste and rename to just main.tf and move into, you can see that's there. And if I just run a terraform FMT, happens instantly you can see that it has formatted all those things to make them a little bit readable. Now more to the point, because terraform is not whitespace dependent like YAML, it may do things like this. So whereas before in the source all of these were single space separated between the equal signs there, in this case it will give me an equal number of spaces to ensure that my arguments are aligned. So it makes it very easy to say here's my values and my arguments inside of a map or inside of a single assignment and correlate them appropriately. So everything's nested in a very nice and convenient way. Again, not a necessity, but these things are kind of creature comforts as we start sharing code to ensure that we're all on the same page. All right. Visualizing object relationships. So when we're working with terraform, we all know, and like I said before, that it's end state declarative. I write what I want to build and I build that. And if you really want to know how terraform does that, you can, when I pass the slides or hand the slides off into the WebEx room, you can click on that link and there is a compendium. I mean it is pages and pages of how terraform goes about building its individual resource graphs. Long story short, when you build a provider, there's lots of dependencies that go into that based on how that's structured. And when you do that, sorry, when the provider is built like that, that's how we can guarantee that when I say in the case of ACI, we have a tenant and a VRF and a bridge domain and a subnet and contracts and filters and all the things that go behind that, we can ensure that the order that they will be applied will not cause anything to break. Unlike Ansible, where I have to make sure that order A, B, C, and D is there, I do not have to do that with terraform. That's why we use it, especially for cloud. However, when it comes to the visualization of how these things flow, you can actually use terraform to build a graph of what that will look like and all those dependencies. And not only does it build based on the individual provider itself, but if you've ever used the depends on argument inside of terraform, where we say maybe in Azure, we're building like a VPN, or we have a network that's set up that we're going to have a VPN tied to, we need to make sure we have those subnets applied to that network prior to building that VPN because there's a dependency there. We do depends on, it will add those as elements into that graph. Now by default, it visualizes it in dot format, and I'll show what that looks like, but that's something built by graph viz. But using the dot command and graph is built in, if you have it installed, whether it's your Mac or your Linux PC, you can convert that to a PNG. Now what's important about this is when we run that terraform graph command, it uses all files in the project folder. So just like the normal terraform routine, we have to do the init, and then we would do a plan normally. You still have to make sure that the init is there because if you're using a third party provider, it has to be there to build that resource graph, and then more appropriately, if you're doing something remote, it may need to be able to communicate if you have a tf.state file in there as well because it's got to read that current state of information before it can say here's how that resource graph looks. In my case, I have a clean folder so you can do it, but if you have an existing terraform state, you will need to make sure that you have some kind of connect to that existing resource because it's going to read in that state as well for any changes because it's reading the current state of that terraform plan. Makes sense? So a .file kind of looks like this, and you can see where it makes sense. We've got some labels of things. We've got different shapes that are defined there, and you can kind of discern what this looks like. This is no different. I know that in the olden days, there was a cumulus Linux platform that would do something similar for the white box stuff, but anyway, you can see where this all comes out, and you can see, okay, I can shape that together. However, if we go here to our graph, and I will show that here real quick. So in this case, this is something that I've demonstrated, probably ad nauseum for ACI demonstrations. So I'm just using the ACI provider. I have some variables here, username, password, URL to access the ACI fabric. I've built some bridge domains, some subnets, a VRF, a tenant. Now, if you look at this and you're familiar with ACI, you say that's out of order. We have this bridge domain defined before we have our tenant, before our VRF, and those kinds of things, but because of that resource graph, Terraform will handle that natively and say, I'm going to construct it in the way that makes sense, and you can prove that out by using the terraform graph command. So what I'm going to do here rather than me typing this, so we can do terraform graph. In this case, I'm going to look at a plan. So what's going to happen when we go through the plan, you can do a type action. So there may be a difference between a plan and an action, I'm sorry, apply based on the terraform state, and I also include the dash draw cycles. Now, if anyone has run some very complex terraform plans, have you ever noticed where sometimes it has to go through twice or three times before it will complete everything because of the order in which it has to wait and build? So you build some stuff and then it has to rest, or maybe you've done some parallelism, then it has to go back and complete the second cycle. If we include the draw cycles, it doesn't do anything for this one because it's simple. If you include draw cycles, it would include the recursion that has to happen through that terraform plan. So just the draw cycles, oops, and you can see it depends on having the terraform initialized. So let's do the terraform init, bad on me. Come on, internet. Perfect. Okay, so the terraform graph, and you can see that's just that same output that I had before, nothing fancy, but it is building based on that main.tf and the variables.tf, so it's reading all those files in to build what it will look like. And then if we go one step further by doing this, where we pipe it to dot and then do the output as being a PNG and then redirect that to tfcycle.png, we should have a new image right here. And that's what it looks like. So you can see the hierarchical order that would be normally expected to build these things inside of ACI. We now have the provider which ties the tenant, the VRF, the bridge domain, the subnet, that hierarchy is built, and on top of that you can see where each one of those variables is referenced. So we have a nice handy visualization that you can hand off to someone to say, here's my terraform file, but here's the output of what that will build with the included names, because you can see it still includes that dotted tuple, so the ACI bridge domain dot terraform BD, that aligns the names that I put inside of my terraform plan, so you can correlate, here's the order, here's the variable names, here's the resource names, and align that all together. So it's handy to be able to document that, if nothing else, as part of your documentation to say, here's what the automation did for me. Okay, now probably more why you're all here, because you want to know more than just the creature comforts. So I want to talk about interactive-ish terraform. So generally, when we work with terraform, this is the cycle that we follow, and we write our HCL, we do a terraform plan, because we want to know what we're doing before we do it, we do a terraform apply, invariably if I'm writing a terraform plan, something's gonna break in there. Maybe I don't have my variables associated the right way, maybe something doesn't apply the right way, maybe I've got some dependencies, so something's broken, and I'm going to rewrite my HCL to figure that out. And that can be time-consuming, because it's like there's got to be a way where we can interrogate the variables of the data structures that we're building ahead of time, so we know our HCL is gonna work the first time every time. But typically, this is my cycle, and it works fine for simple HCL, since most of your errors are probably like syntactical, or if you're like me, you can't type half the time, especially when people are watching. More often than not, we'll do a very simple variable, so we have simple assignments or simple maps, so that makes it easy to troubleshoot. But we want to be able to interact with terraform in a way, especially at a variable level, to say how can I ensure if I have a data structure, whether that's defined based on some organizational standard, whether that's output from Netbox, or some other single source of truth, or maybe we have some output data from a CSV file, how do I know that that output is going to be manipulated in such a way for a structure that I can automate against? I mean, really, that's the hard part. Everything else is just writing HCL, but we need to make sure we have the right data coming in to apply it correctly going out. So terraform has a console. Anybody know that before? Anybody use terraform console? So terraform console allows for interactive interrogation of terraform. So we can look at things like variables, we can look at configuration, we can look at the state file if it's already been applied, so we can gather that data out of terraform. And what I use it for more often than not is variable and data interpolations based on built-in functions within terraform. So there's things like flattened, there's things like squash, there's things that we can manipulate, and I'll show what those structures look like to be able to say we have this map, do some queries on that map, spit out this condition if switches a spine, and what does that look like? So I use that to manipulate my variables before I write my HCL to know here's the data structure and here's how I need to build my terraform plan. However, and I will demonstrate this as well, the terraform console is not a REPL. So with Python, we have the interactive Python where we can say, you know, assign variables and we can build our entire function inside of that REPL and validate it that it works beforehand. We cannot do the full set of REPL operations in terraform console. So it's mostly like a static piece. There are some, it will build your files, it will look at your files, it will gather them all together, but it's not an interactive REPL type console. So what I want to do here is demo a lot of this. So let's go simple interrogation. So under this 03, let me close these up, I have this main.tf. Now, I just have a single file here and I've thrown all of my variables inside of what's called locals. Locals in your normal terraform plan is just a way you can store local variables or data structures that you would like to work on. It can ingest full blown terraform plan. So if I was to go back to that graph example, I could also do terraform console there. However, rather than dealing with all the idiosyncrasies, I've just tossed a bunch of things here in locals so I can do some very, some simple variable manipulation here. So I have a blank variable called leafs. I have a simple assignment called session ID and I have this thing called user, this map called user, I have username, password, URL, and I have this thing called fabric and some leaf for stuff. So to access the terraform console, I'll just do terraform console. And you can see here that I have this terraform.tfstate backup or lock info and terraform.tfstate. Just like with terraform graph, if I have something that depends on a provider, I need to do a terraform init first because it needs to know how to interact with it. However, because I've tossed everything in locals, it just builds a temporary terraform.tfstate as well as a lock to say no one else can modify this before you're out of the console because you're directly interacting with that HCL. So in the repository that I have linked at the very end of this presentation, I have this command.text file. So you can reference this again. This is so I don't fat finger anything when I copy paste. So we can do simple variable lookup. So we can do like local, oops, do something called local.session ID. And we can spit back a value so we can see that that is ingested in the sign. We can go a little bit deeper. We can go local.user.username. So we can pick back individual pieces of our map. So just like you would reference as a var.user.username, same thing you can do within the console. We can do some simple, let's see here if I have that there. Yeah, so we can do some simple stuff. I think we have this leaf4. Yeah, so we have this leaf4. We could actually split these things up. So in this case, I have the split function. So split just says kind of just as you would in Python, we have split the variable local.leaf4.ip based on the dot inside of the octet. So in this case, I can run something like that. And it splits it out to a list. So now I have a list object there where it has 10, 10, 20, and 176. So it's divided each of those octets into a list. And then on top of that, because it's a list item, I can then query an individual item within that list. So I can do the same types of functions that I would normally inside of any other programming language. So I can take that and split that out. Again, this is just an esoteric example. But if I need to do something a little bit deeper to dive in, maybe I've got a list I need to extract something out, I can reference those items based on the list value and number. The other way that I use this is we'll go a little bit deeper here. And we have this again, something simple. It's just a list of maps. I have a map called, sorry, the first item in that list is called item one with values A and B. The second map in that list is item two with values B and C. So what I want to do here is test the list. So I'm going to is test. Maybe you have some kind of data structure where you need to ensure that I have item one tied to value A and B and item two tied to value B and C. So in that case, I have this sample variable file or sorry, sample manipulation called squashed. And in this case, I'm going to flatten that set of lists. So it's all flattened out. And then I'm going to do some simple, well, not so simple because it's a little bit confusing my variable names here, but I'm going to do some iterations over that flattened set of lists. So for entry in the list of maps, for the thing in the values of entry, create a map denoted by the brackets here. And this is the one thing that is very important with Terraform console. You can see where I have the curly braces there. Everything instead of a curly brace denotes a map. If I was to move that to square brackets, I would have a value error because I'm not creating a list. I'm creating a map, which is like a Python dictionary of key value pairs. So you need to make sure that you're through all of this, you need to make sure that you have your, I don't know, delimiters correct. So in this case, my list is the square brackets, a map is those curly braces. So if I run this, hopefully something's not broken. All right, let's try it anyway. So because it's in locals, and because Terraform automatically initializes all of these different items, it says I'm going to compute everything before I fire up the console. So I should be able to do local.squashed, and you can see that it has taken A in item one, B in item one, B in item two, and C in item two. So I've created a set of pairs instead of having those reference lists. What this is illustrating is that when I run Terraform console, it's actually initializing every piece of resource and data source and everything else inside of that code prior to running the console. So you can use this as a validation point prior to doing a Terraform plan, prior to doing a Terraform apply, to make sure do things look right based on my outputs. And I can view outputs through here, I can view variables, I can view locals, etc. Exit out of here, and we'll do some final examples with some more complex manipulation in this main.tf. So in this case, I have kind of similar to what I had before. I had these leafs equals this, sessions IDs, and I have this fabric inventory based on spines and leafs and things like that. Then I have this demo VRFs, VRF A and B. So first of all, just to illustrate this, I can iterate through, let's see here, Terraform console. For the object in the local fabric inventory, so remember that's that set of the list of maps here, print the name of each of those, or print the value of the name variable. So in this case, it's going to be leaf1, leaf2, spine1, spine2. You can see here, it's going to enter the value of the map. You can see here, it's going to iterate through those things. So we can capture out just as we did before, where we captured the individual values out of those maps. We can do that across the list. But as an example here, like I've said before, it's important to make sure that we have the right structure that we're building with the right delimiter. Because this is the same thing, but I've used curly brackets instead of squares. And you can see it's failing. Key expression is required when building an object. So it will tell you where you have those syntactical errors with inside of your Terraform structures ahead of time. Another nice thing is what Terraform calls the splat. So instead of having that loop list where I said for all in local fabric, I can just do local fabric inventory splat and gather that same bit of information using that. So I can iterate over a list without having to build a loop for it. I can build maps. So we can see here four key value in the inventory. So whenever I build a complex expression inside of Terraform, I have my loop defined there. And if I want to do one line, I will do a colon to separate that. And then to build a key value pair like I would in Go, it's key arrow value. So this should build a set of maps based on number there. So I've given it a name based on the number there. So I basically just constricted. I've created a map of maps instead of the list of maps. And that also works across the splat character here. And I get the same item there. We can build lists again because we have the square brackets. I just want to gather all the rolls out of that local fabric inventory. And I would do that here. Gather those things out. And then finally, I'll do some complex manipulations here just to save some time. Sounds like they're having fun. In this case, I'm doing a little bit more of a manipulation. Same thing as I did before. Build a map, but only if the value of the roll field is set to spine. So I can do some parsing of the local objects based on conditional matching just as I would with any other programming language. Make sure it's copied and paste. So now I only have the information of the values. Sorry, the information gathered by having the, in this case, it was roll equals spine. So we can do a lot of complex manipulations of our data structures ahead of time without having to guess and check. Now the one thing that I do want to touch on is, oh, this right here. So two other things actually. Where I said that it's not a REPL. So in this case, I would expect a normal programming language. Remember I had that variable called leafs defined. It's an empty map. I would expect that if this was a REPL, I've created that variable, I've initialized it, I should be able to store something there, right? That's how it would work in Python. I create the variable and I can store something. In this case, I have that command that says store the output of what I did before, but store it as the value called leafs. So I can reference that map later on. If I try to do that, it fails. So it's not a full-blown REPL. So you have to work through your data manipulation in the correct way based on the console, but you can't actually store the variables. You've got to do that in your code like I had in the previous example. Do the manipulation and then query the variable afterwards. And then finally, you can also do some text manipulation. In this case, I'm just throwing demo in front of a value here. So I have, I remember that list, we had VRFA and VRFB. I've given them new names, demo VRFA and demo VRFB. Sweet. Okay. Let's get out of the console here. Now finally, oops. Let's talk about abstraction. How many folks have worked with Ansible and Ansible roles before? They simplify a lot of things, right? Where you can say, let's hide all the complex underneath. Let's only present a few variables that we want someone to modify and edit in order to build an entire fleet of something or maybe a whole engine X server or whatever. So Terraform has something similar. They're called modules and it does the same thing. It provides a simplification and abstraction of a configuration. Now what's important about this is every project directory. So every, in this case, this is an example I use for when I teach Terraform and ACI. 01, 02, 03, 04, each of those could be considered a module, even though they're only a single level. So it can get a little weird the way that Hashtecorp references it, but every project directory is a module in the eyes of Terraform because it's going to take, if I was to nest any folder or any other Terraform file underneath these, it would collapse those all up into one and perform the automation. Which is why, so like I said, within a root module, all Terraform files are analyzed and interpreted, interpolated even in subfolders. So because of that, we can build the concept of a module very easily. Unlike an Ansible, we have to have a specific roles directory defined in our Ansible CFG. By default, everything inside of a Terraform directory is considered, you know, fair, fair game to be able to use. So in this case, I have the sub submodule folder where I have a main.tf, an outputs.tf, a variables.tf. When I run Terraform plan on the top level main.tf, it will take in everything from that submodule and present that northbound, so all that automation is included. This way we can do a lot of our routines in that submodule piece. We can define our outputs of what we want things to look like and we can abstract. So only main.tf is something that's very simple and is very foolproof, you should say. Now Terraform has a really good set of instructions on when to build modules. This is kind of a distillation of that. If you want to simplify your configuration, so maybe do a lot of repetition. The same thing over and over and over again. In my example, I'm building ACI tenants. All the same stuff, we know we're going to change some variable names for the top level tenant, but maybe we want our VRF, our bridge domain, and things like that to follow along that same pattern. So we don't want to have someone modifying all those different variables. Let's just build a module, feed it one name, feed it a subnet IP, and we're good to go. You can prevent configuration issues. So if you do something, like I said, if you do something a lot or you have like a VPN that you want to build as part of something, the VPN configuration can be hidden away inside of a module, and so you only have to deal with the top level tenants and things like that. Then the reuse of configuration. So let me get in here. Yep, eight minutes left. Let's show you how this works. So in this 06 modules folder, I have this ACI tenant folder. So I have this 06 modules and I have a folder called modules, and under that I have this ACI tenant. I have a main.tf, which defines the provider I'm going to use. In this case, it's ACI. How to connect to that ACI fabric and then how to build the things that I want. In this case, it's a tenant, a VRF, a bridge domain, and a subnet. Now you notice here, I have a reference to a specific variable. Now in Terraform, if I have something with a dollar sign ensconced by the curly braces, that's variable interpolation. So that says instead of referencing that variable directly, get the name of that variable and stick it in there. So if I have a variable called aardvark, it would be aardvark-vrf. And I like to use the word aardvark because it's fun to say, but it also shows up at the top of ACI. It's a AA, so it shows up at the very top of my ACI fabric. So I interpret each of those variables and fill that name into this specific string for each one of those things. And you can see how I built my automation. So I'm always referencing that tenant name and just changing the suffix after that. So bridge domain, things like that. And then I have a specific one for my cedar block. My variables, I've just hidden away my, and I'm going to copy this because I know my fabric is timed out. I built in variables, so in this case it's just the ACI always on sandbox within DevNet. And I've defined, because it's Go and I have to initialize the structures ahead of time, I've just defined blank variables for tenant, vrf, and bridge domain, and subnet. So there's no values there. I haven't set a default argument, but I've just initialized those variables so they can be accessed by Terraform. And then finally, I have an output. Because we want to make sure that our automation behaves the way we expect it to, I defined two output variables inside this output.tf. In this case, name of the vrf and the name of the bridge domain. And those directly reference the values that were here in this main.tf. Clear so far? Now on the top level project, I have a main.tf where I'm just using this, oh I'm sorry, the module is actually called ACI tenant skeleton. Missed that one there. So I have this module and I'm using the source as the ACI tenant skeleton folder. So read in the Terraform files from there and treat it as a module. I define my tenant name, the variable that I defined earlier, var.tenant.name. In this case, I've just called it aardvark1. And I defined a cedar block, 1010.1.0.0.1. So I'm creating a tenant as I would normally with Terraform, but all I have done is reference a tenant name and a cedar block because the module is automating everything else. Remember I built the vrf, the bridge domain based on the tenant name, all that's been hidden away by the module. I have a variables.tf with nothing in it, so there's nothing on my sleeve here, no trickery. And my outputs.tf, I have the vrf name and the bridge domain name printed on the output of my Terraform run. Now you notice the one difference here is instead of referencing the outputs directly, I reference them as a child of the module. So module instead of output dot whatever, aci-tenant-scaffold, which is the name that I assigned to the module, and then dot bd. And same with vrf. So I can reference those outputs and they will show up at the end of my Terraform run. So scrolling up here, and let's do a Terraform init. The one thing I will say is that because I'm using a non-standard provider, you have to reference the provider both in both main.tfs essentially. You have to reference it in the module and reference it in the the top level project as well. Otherwise you'll say looking for hashcorp-aci and it will fail. So you've got to reference that name there. So we've done an init. Let's do a Terraform plan, out tf.plan. And you can see it is built or it is planned everything based on the outputs that I've given it. So we have the cedar block there and you can see that we have the outputs, the bridge domain and vrf name referencing the output of the Terraform plan itself. So by assigning a tenant name and a cedar block, I've hidden away the rest of the abstraction, but an entire aci tenant would be built. And just to show you that everything is actually going to function as planned, I'm going to apply this and also jump over here. And of course I copy paste it and can't find the, oh no. This is an internet problem. I promise you this worked yesterday. Yeah, well I like to live and die by the demo. So let's go to the module here and I bet it's under main.tf. Actually, variables.tf. No, that should work. It's saying it can't log in, which probably is related to the fact that I needed this demo. Or maybe the fabric died, who knows. All right, I promise you under normal conditions this would work, but it's not logging in, so I'm betting that's the case. So you should be able to take this code and apply it towards a normal production fabric and everything would work. I can record a video and show you that it does work and post it in the WebEx room. But yeah, we're having some login problems. I'm willing to bet that the fabric, the always on controller died because I can't log in. Anyway, in a perfect world, we get that aardvark tenant being applied and you would be able to see it in the tenant listing there just as you would inside the plan. Yeah, something's broke. Okay, let me slide back over here. Wrapping it all up, of course I don't have the sample code here. Join the WebEx space. I will post the QR code there. I don't know why I didn't save it. Anyway, join the WebEx space. I will post the sample code. Please fill out your session surveys. I think you've formed your offer to a free t-shirt and I'll be around for the rest of the week over in the Cisco U learning and certifications booth to talk Terraform, Kubernetes, Docker, anything else that your heart desires. Thank you so much for your time.